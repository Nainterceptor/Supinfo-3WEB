<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>SUPINFO Low-Level Laboratory</title><link>http://www.lab-sl3.org/</link><description></description><atom:link href="http://www.lab-sl3.org/feeds/all.rss.xml" rel="self"></atom:link><lastBuildDate>Thu, 26 Sep 2013 00:00:00 +0200</lastBuildDate><item><title>Traitement d'image: Trivial Steganography</title><link>http://www.lab-sl3.org/articles/news/traitement-dimage-trivial-steganography.html</link><description>&lt;p&gt;La &lt;a href="http://fr.wikipedia.org/wiki/Stéganographie"&gt;stéganographie&lt;/a&gt; est l'art de dissimuler de l'information dans un document. L'objectif est qu'une personne qui voit le document ne se doute pas qu'une information y est dissimulée.&lt;/p&gt;
&lt;p&gt;Tout l'enjeu réside dans le fait que même en connaissant la méthode de dissimulation, une personne récupérant l'image ne doit pas pouvoir déterminer si une information s'y cache ou non. Cependant dans un souci de simplicité nous nous limiterons à présenter un schéma pour lequel une personne ne peut distinguer à l'oeil nu si un document a été stéganographié.&lt;/p&gt;
&lt;p&gt;Nous pouvons stocker n'importe quel type d'information tel qu'un texte, un copyright, un son ou encore une image dans un document qu'il soit textuel, sonore, ou qu'il s'agisse d'une image. &lt;/p&gt;
&lt;p&gt;Un schéma de stéganographie est composé de deux algorithmes : &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dissimulation&lt;/li&gt;
&lt;li&gt;Extraction&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;L'algorithme de dissimulation prend en paramètre un document original et le document à dissimuler, et va générer un document stéganographié. L'algorithme d'extraction va quant à lui prendre en paramètre un document stéganographié et va retourner le document dissimulé une fois extrait.&lt;/p&gt;
&lt;p&gt;Dans cet article nous allons voir comment dissimuler une image dans une autre, en utilisant un algorithme simple mais efficace. Il consiste à modifier les pixels d'une certaine manière. Nous verrons également comment extraire l'image dissimulée. &lt;/p&gt;
&lt;p&gt;Pour ce faire, nous allons dans un premier temps voir quelques rappels sur le binaire et ses opérateurs. Puis nous verrons un exemple d'utilisation de la bibliothèque &lt;a href="http://cimg.sourceforge.net"&gt;CImg&lt;/a&gt; qui permet de travailler sur des images. Ensuite nous décrirons les deux algorithmes du schéma de la stéganographie : la dissimulation et l'extraction.&lt;/p&gt;
&lt;p&gt;Et pour finir nous vous donnerons quelques pistes pour aller plus loin dans la stéganographie.&lt;/p&gt;
&lt;h2&gt;Le binaire&lt;/h2&gt;
&lt;p&gt;Nous allons tout d'abord voir quelques rappels sur le binaire qui seront essentiels par la suite.&lt;/p&gt;
&lt;p&gt;Le système binaire est un système de numération utilisant la base 2. On nomme couramment bit les chiffres binaires. Ceux-ci ne peuvent prendre que deux valeurs: 0 ou 1. Un ensemble de huit chiffres binaires est appelé un octet et peut stocker 2^8 (= 256) valeurs différentes soit de 0 à 255 inclus. &lt;/p&gt;
&lt;p&gt;Prenons un exemple, nous souhaitons convertir 1001 1011 en décimal.
Chaque bit d'un octet correspond à une puissance de 2. Le premier bit (le plus à droite) représente 2^0 = 1, le deuxième 2^1 = 2, le troisième 2^2 = 4, le quatrième 2^3 = 8 et ainsi de suite. Il ne reste plus qu'à additionner les valeurs correspondantes aux bits à 1 pour récupérer le nombre en décimal.&lt;/p&gt;
&lt;p&gt;Voici notre nombre binaire écrit verticalement :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;128&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;128&lt;/span&gt;
&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;64&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="mi"&gt;16&lt;/span&gt;

&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="mi"&gt;128&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;155&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;1001 1011 correspond donc à 155.&lt;/p&gt;
&lt;p&gt;Tous les bits d'un octet ont un poids, qui correspond à leur position dans l'octet. On appelle bits de poids fort les bits se trouvant à gauche de l'octet, car ils ont une forte influence sur la valeur de l'octet (128, 64 ...). A contrario les bits à droite sont appelés bits de poids faible car ils influent peu sur l'octet (1, 2, 4 ...).&lt;/p&gt;
&lt;h2&gt;Les opérateurs binaires&lt;/h2&gt;
&lt;p&gt;Nous allons maintenant revoir quelques opérations binaires, qui vont nous être très utiles pour la suite.&lt;/p&gt;
&lt;p&gt;En C++ il existe plusieurs types d'opérateurs, les plus classiques sont les opérateurs de calcul (+, -, *, /, %, ++, +=, ...), les opérateurs de comparaison (&amp;lt;, &amp;lt;=, !=, ...) et les opérateurs logiques (||, &amp;amp;&amp;amp;, !).&lt;/p&gt;
&lt;p&gt;Mais il existe également des opérateurs bit-à-bit :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;amp; (ET binaire) : Retourne 1 si les deux bits de même poids sont à 1. Exemple (9 &amp;amp; 12) renverra 8 car en binaire cela donne (1001 &amp;amp; 1100 -&amp;gt; 1000)&lt;/li&gt;
&lt;li&gt;| (OU binaire) : Retourne 1 si l'un ou l'autre des deux bits de même poids est à 1 (ou les deux). Exemple (9 | 12) renverra 13 car en binaire cela donne (1001 | 1100 -&amp;gt; 1101)&lt;/li&gt;
&lt;li&gt;^ (OU-Exclusif) : Retourne 1 si les deux bits de même poids sont différents. Exemple (9 ^ 12) renverra 5 car en binaire cela donne (1001 ^ 1100 -&amp;gt; 0101)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Il existe aussi deux opérateurs de décalage de bits :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lt;&amp;lt; (décalage à gauche) : Décale les bits vers la gauche et remplit les bits à droite par des 0 (multiplie par 2 à chaque décalage).
             Exemple (6 &amp;lt;&amp;lt; 1) renverra 12 car on décale une fois 6 vers la gauche soit (0110 &amp;lt;&amp;lt; 1 -&amp;gt; 1100)&lt;/li&gt;
&lt;li&gt;&gt;&gt; (décalage à droite) : Décale les bits vers la droite et remplit les bits à gauche par des 0 (divise par 2 à chaque décalage).
             Exemple (6 &amp;gt;&amp;gt; 2) renverra 1 car on décale deux fois 6 vers la droite soit (0110 &amp;gt;&amp;gt; 2 -&amp;gt; 0001)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Le traitement d'image&lt;/h2&gt;
&lt;p&gt;En informatique, une image est représentée par une matrice (un tableau à deux dimensions). Chaque cellule de la matrice correspond à un pixel et un pixel est composé de trois couleurs : le rouge, le vert et le bleu. Les couleurs sont des entiers, dans nos exemples les valeurs seront comprises entre 0 et 255.&lt;/p&gt;
&lt;p&gt;Par exemple le pixel ayant comme valeur (R, V, B) (255, 0, 0) sera rouge et le pixel (255, 255, 0) sera jaune.&lt;/p&gt;
&lt;p&gt;Nous utiliserons dans cette article la bibliothèque C++ &lt;a href="http://cimg.sourceforge.net"&gt;CImg&lt;/a&gt; pour ouvrir, lire et modifier des images. &lt;/p&gt;
&lt;p&gt;Voici un exemple simple d'utilisation où nous allons juste inverser les couleurs d'une image. Le rouge sera remplacé par le vert, le vert par le bleu et le bleu par le rouge.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="c1"&gt;// Création d&amp;#39;un typedef afin d&amp;#39;éviter de réécrire le type à chaque utilisation&lt;/span&gt;
  &lt;span class="c1"&gt;// Une ImageUchar est une image ou chaque couleur est codée sur 1 octet (unsigned char ou uint8_t)&lt;/span&gt;
  &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;cimg_library&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;CImg&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;ImageUchar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// Chargement de l&amp;#39;image&lt;/span&gt;
  &lt;span class="n"&gt;ImageUchar&lt;/span&gt; &lt;span class="nf"&gt;image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;foo.bmp&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="c1"&gt;// Double boucle sur la hauteur et la largeur de l&amp;#39;image afin de parcourir tous ses pixels&lt;/span&gt;
  &lt;span class="c1"&gt;// Le pixel (0, 0) se trouve en haut à gauche de l&amp;#39;image&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="c1"&gt;// Récupération des trois couleurs&lt;/span&gt;
          &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;rouge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
          &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;vert&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
          &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;bleu&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

          &lt;span class="c1"&gt;// Inversion des couleurs&lt;/span&gt;
          &lt;span class="c1"&gt;// Le rouge (0) est remplacé par le vert&lt;/span&gt;
          &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vert&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
          &lt;span class="c1"&gt;// Le vert (1) est remplacé par le bleu&lt;/span&gt;
          &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bleu&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
          &lt;span class="c1"&gt;// Le bleu (2) est remplacé par le rouge&lt;/span&gt;
          &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rouge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// Affiche l&amp;#39;image après l&amp;#39;inversion des couleurs&lt;/span&gt;
  &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;display&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;On observe bien sur l'image résultat que les couleurs ont été inversées.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="Couleurs inversées" src="https://bitbucket.org/TrashZen/trivial-steganography/raw/35131b8d002f5c83360bd5ff411ceeee69bf48ec/doc/resources/inverse_couleurs.jpg" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;h2&gt;La stéganographie, les choses sérieuses commencent !&lt;/h2&gt;
&lt;h3&gt;La dissimulation&lt;/h3&gt;
&lt;p&gt;Il existe bien entendu plusieurs schémas de stéganographie. Nous allons ici voir un algorithme simple mais efficace permettant de dissimuler une image en noir et blanc dans une image en couleur de même taille.&lt;/p&gt;
&lt;p&gt;Cet algorithme (appelé LSB pour Least Significant Bit) consiste à modifier les bits de poids faible de chaque pixel. Cela a pour conséquence d'augmenter ou de diminuer légèrement les valeurs de rouge, vert et bleu. La couleur du pixel se trouve donc peu modifiée mais contient une partie de l'information que nous souhaitons dissimuler.&lt;/p&gt;
&lt;p&gt;Nous appellerons &lt;code&gt;im_rvb&lt;/code&gt; l'image couleur, et &lt;code&gt;im_gris&lt;/code&gt; l'image à dissimuler. Chaque pixel de &lt;code&gt;im_gris&lt;/code&gt; sera dissimulé dans le pixel de &lt;code&gt;im_rvb&lt;/code&gt; aux mêmes coordonnées.&lt;/p&gt;
&lt;p&gt;Pour chaque pixel, la première étape consiste à découper le pixel de &lt;code&gt;im_gris&lt;/code&gt; (stocké sur un octet) en trois parties :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Deux parties de trois bits&lt;/li&gt;
&lt;li&gt;Une partie de deux bits&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Car 3 + 3 + 2 = 8 bits soit un octet. Ensuite nous allons remplacer les trois bits de poids faible de la composante rouge de &lt;code&gt;im_rvb&lt;/code&gt; par la première partie de &lt;code&gt;im_gris&lt;/code&gt;. Puis nous remplaçons les deux bits de poids faible de la composante verte de &lt;code&gt;im_rvb&lt;/code&gt; par la deuxième partie de &lt;code&gt;im_gris&lt;/code&gt;. Enfin nous remplacerons les trois bits de poids faible de la composante bleue de &lt;code&gt;im_rvb&lt;/code&gt; par la troisième partie de &lt;code&gt;im_gris&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Voici un exemple concret : nous allons dissimuler un pixel gris (103) dans un pixel couleur (132, 43, 84). Nous commençons par convertir 103 en binaire: 0110 0111. Puis nous le découpons en trois parties.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="n"&gt;partie&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;011&lt;/span&gt;
  &lt;span class="n"&gt;partie&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;00&lt;/span&gt;
  &lt;span class="n"&gt;partie&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;111&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ensuite nous convertissons les trois valeurs du pixel couleur en binaire.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="mi"&gt;132&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="mo"&gt;0100&lt;/span&gt;
  &lt;span class="mi"&gt;43&lt;/span&gt;  &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="mo"&gt;0010&lt;/span&gt; &lt;span class="mi"&gt;1011&lt;/span&gt;
  &lt;span class="mi"&gt;84&lt;/span&gt;  &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="mo"&gt;0101&lt;/span&gt; &lt;span class="mo"&gt;0100&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Nous retirons les bits de poids faible du pixel couleur.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="mf"&gt;0.&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;
  &lt;span class="mo"&gt;0010&lt;/span&gt; &lt;span class="mf"&gt;10.&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
  &lt;span class="mo"&gt;0101&lt;/span&gt; &lt;span class="mf"&gt;0.&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Et nous les remplaçons par les trois parties extraites précédemment.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="m"&gt;1000&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="kc"&gt;...&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;011&lt;/span&gt;
  &lt;span class="m"&gt;1000&lt;/span&gt; &lt;span class="m"&gt;0011&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; qui correspond à &lt;span class="m"&gt;131&lt;/span&gt;

  &lt;span class="m"&gt;0010&lt;/span&gt; &lt;span class="m"&gt;10&lt;/span&gt;.. &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;00&lt;/span&gt;
  &lt;span class="m"&gt;0010&lt;/span&gt; &lt;span class="m"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; qui correspond à &lt;span class="m"&gt;40&lt;/span&gt;

  &lt;span class="m"&gt;0101&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="kc"&gt;...&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;111&lt;/span&gt;
  &lt;span class="m"&gt;0101&lt;/span&gt; &lt;span class="m"&gt;0111&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; qui correspond à &lt;span class="m"&gt;87&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Le pixel (132, 43, 84) devient donc (131, 40, 87). On voit que la différence entre les deux est faible et ne sera pas visible à l'oeil nu.&lt;/p&gt;
&lt;p&gt;Voici une application en C++ :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;   * Dissimuler une image en niveau de gris (image_to_hide) dans une image couleur (image_couleur).&lt;/span&gt;
&lt;span class="cm"&gt;   *&lt;/span&gt;
&lt;span class="cm"&gt;   * Soit un pixel P de image_couleur composé de trois octets, R pour le rouge, V pour le vert, B pour le bleu&lt;/span&gt;
&lt;span class="cm"&gt;   *   rouge = R0 R1 R2 R3 R4 R5 R6 R7 -&amp;gt; 8 bits contenant le niveau de rouge&lt;/span&gt;
&lt;span class="cm"&gt;   *   vert  = V0 V1 V2 V3 V4 V5 V6 V7 -&amp;gt; 8 bits contenant le niveau de vert&lt;/span&gt;
&lt;span class="cm"&gt;   *   bleu  = B0 B1 B2 B3 B4 B5 B6 B7 -&amp;gt; 8 bits contenant le niveau de bleu&lt;/span&gt;
&lt;span class="cm"&gt;   * &lt;/span&gt;
&lt;span class="cm"&gt;   * et un pixel Pg de image_to_hide composé d&amp;#39;un octet contenant la nuance de gris&lt;/span&gt;
&lt;span class="cm"&gt;   *   gris  = G0 G1 G2 G3 G4 G5 G6 G7 -&amp;gt; 8 bits contenant le niveau de gris&lt;/span&gt;
&lt;span class="cm"&gt;   *&lt;/span&gt;
&lt;span class="cm"&gt;   * alors nous allons remplacer certains bits de P de la façon suivante pour dissimuler Pg dans P :&lt;/span&gt;
&lt;span class="cm"&gt;   *   rouge = R0 R1 R2 R3 R4 G0 G1 G2&lt;/span&gt;
&lt;span class="cm"&gt;   *   vert  = V0 V1 V2 V3 V4 V5 G3 G4&lt;/span&gt;
&lt;span class="cm"&gt;   *   bleu  = B0 B1 B2 B3 B4 G5 G6 G7&lt;/span&gt;
&lt;span class="cm"&gt;   *&lt;/span&gt;
&lt;span class="cm"&gt;   * @param image_to_hide [in]      Image en niveau de gris à dissimuler&lt;/span&gt;
&lt;span class="cm"&gt;   * @param image_couleur [in, out] Image original&lt;/span&gt;
&lt;span class="cm"&gt;   */&lt;/span&gt;
  &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;hide&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;ImageUchar&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;image_to_hide&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ImageUchar&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;image_couleur&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="c1"&gt;// Double boucle (une pour la hauteur, une pour la largeur) permetant de parcourir tous les pixels de image_couleur&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;image_couleur&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;image_couleur&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="c1"&gt;// La première étape consiste à découper le pixel de image_to_hide&lt;/span&gt;
        &lt;span class="c1"&gt;// (contenu sur un octet car c&amp;#39;est une image en noir et blanc)&lt;/span&gt;
        &lt;span class="c1"&gt;// en trois parties : la première doit faire trois bits, la deuxième deux bits et la troisième trois bits.&lt;/span&gt;
        &lt;span class="c1"&gt;// Soit 3 + 2 + 3 = 8 bits = 1 octet&lt;/span&gt;

        &lt;span class="c1"&gt;// Initialisation des trois variables contenant chacune une partie du pixel&lt;/span&gt;
        &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;part_1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;part_2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;part_3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="c1"&gt;// Vérifie que image_to_hide contient un pixel aux coordonnées (x, y)&lt;/span&gt;
        &lt;span class="c1"&gt;// Cela évite d&amp;#39;accéder à un pixel qui se trouve en dehors de l&amp;#39;image&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image_to_hide&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;containsXYZC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="c1"&gt;// image_to_hide(x, y) -&amp;gt; valeur du pixel au coordonnées (x, y) contenu sur un octet (8 bits)&lt;/span&gt;
          &lt;span class="c1"&gt;//&lt;/span&gt;
          &lt;span class="c1"&gt;// Récupération des trois premiers bits de l&amp;#39;octet dans part_1&lt;/span&gt;
          &lt;span class="c1"&gt;//&lt;/span&gt;
          &lt;span class="c1"&gt;// image_to_hide(x, y)              -&amp;gt; xxxx xxxx (x vaut 0 ou 1)&lt;/span&gt;
          &lt;span class="c1"&gt;// image_to_hide(x, y) &amp;gt;&amp;gt; 5         -&amp;gt; 0000 0xxx&lt;/span&gt;
          &lt;span class="n"&gt;part_1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;image_to_hide&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

          &lt;span class="c1"&gt;// Récupération des deux bits suivants dans part_2&lt;/span&gt;
          &lt;span class="c1"&gt;//&lt;/span&gt;
          &lt;span class="c1"&gt;// image_to_hide(x, y)              -&amp;gt; xxxx xxxx (x vaut 0 ou 1)&lt;/span&gt;
          &lt;span class="c1"&gt;// image_to_hide(x, y) &amp;amp; 24         -&amp;gt; 000x x000&lt;/span&gt;
          &lt;span class="c1"&gt;// (image_to_hide(x, y) &amp;amp; 24) &amp;gt;&amp;gt; 3  -&amp;gt; 0000 00xx&lt;/span&gt;
          &lt;span class="n"&gt;part_2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image_to_hide&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;  &lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

          &lt;span class="c1"&gt;// Récupération des trois derniers bits dans part_3&lt;/span&gt;
          &lt;span class="c1"&gt;//&lt;/span&gt;
          &lt;span class="c1"&gt;// image_to_hide(x, y)              -&amp;gt; xxxx xxxx (x vaut 0 ou 1)&lt;/span&gt;
          &lt;span class="c1"&gt;// image_to_hide(x, y) &amp;amp; 24         -&amp;gt; 0000 0xxx&lt;/span&gt;
          &lt;span class="n"&gt;part_3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="n"&gt;image_to_hide&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="c1"&gt;// Remplissage des trois derniers bits de l&amp;#39;octet contenant le rouge à 0 (xxxx x000) (x vaut 0 ou 1)&lt;/span&gt;
        &lt;span class="n"&gt;image_couleur&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="mi"&gt;248&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// rouge &amp;amp; 1111 1000&lt;/span&gt;

        &lt;span class="c1"&gt;// Remplissage des deux derniers bits de l&amp;#39;octet contenant le vert à 0 (xxxx xx00)&lt;/span&gt;
        &lt;span class="n"&gt;image_couleur&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="mi"&gt;252&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// vert &amp;amp; 1111 1100&lt;/span&gt;

        &lt;span class="c1"&gt;// Remplissage des trois derniers bits de l&amp;#39;octet contenant le bleu à 0 (xxxx x000)&lt;/span&gt;
        &lt;span class="n"&gt;image_couleur&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="mi"&gt;248&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// bleu &amp;amp; 1111 1000&lt;/span&gt;

        &lt;span class="c1"&gt;// Il ne reste plus qu&amp;#39;à insérer part_1, part_2 et part_3 dans image_couleur, &lt;/span&gt;
        &lt;span class="c1"&gt;// une dans chaque composante (couleur).&lt;/span&gt;
        &lt;span class="c1"&gt;// L&amp;#39;astuce pour que la modification de l&amp;#39;image ne soit pas visible (ou le moins possible) est&lt;/span&gt;
        &lt;span class="c1"&gt;// de modifier les bits de poids faible,&lt;/span&gt;
        &lt;span class="c1"&gt;// ceux les plus à droite. Cela permet de faire varier la valeur de chaque couleur assez faiblement &lt;/span&gt;
        &lt;span class="c1"&gt;// pour ne pas être visible à l&amp;#39;oeil nu.&lt;/span&gt;
        &lt;span class="n"&gt;image_couleur&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;image_couleur&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;part_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// xxxx x000 | 0000 0xxx&lt;/span&gt;
        &lt;span class="n"&gt;image_couleur&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;image_couleur&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;part_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// xxxx xx00 | 0000 00xx&lt;/span&gt;
        &lt;span class="n"&gt;image_couleur&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;image_couleur&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;part_3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// xxxx x000 | 0000 0xxx&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Et voilà le résultat en image de cet algorithme.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="Resumé" src="https://bitbucket.org/TrashZen/trivial-steganography/raw/35131b8d002f5c83360bd5ff411ceeee69bf48ec/doc/resources/resume.jpg" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Si vous avez bien suivi, vous avez dû remarquer qu'on ne modifie que deux bits de la composante verte alors que le bleu et le rouge ont chacun trois bits modifiés. Logique car nous n'avons que huit bits à dissimuler.
Peut-être que certains d'entre vous se sont demandés pourquoi c'est le vert qui reçoit la plus faible modification et non le rouge ou le bleu ?&lt;/p&gt;
&lt;p&gt;La réponse se trouve dans nos yeux ! Et oui, l'oeil humain est plus sensible au vert qu'au rouge ou au bleu. Il est donc préférable de modifier plus faiblement le vert que les autres composantes afin que la dissimulation de l'image soit la plus discrète possible.&lt;/p&gt;
&lt;h3&gt;L'extraction&lt;/h3&gt;
&lt;p&gt;Nous avons vu comment dissimuler une image noir et blanc dans une autre image. Vous pouvez maintenant partager cette image sans que personne ne voit la deuxième image qui s'y cache !&lt;/p&gt;
&lt;p&gt;Une fois que votre correspondant a récupéré cette image, il doit en extraire l'image contenue, pour cela il suffit d'appliquer l'algorithme dans l'autre sens.&lt;/p&gt;
&lt;p&gt;Il faut récupérer les trois derniers bits de la composante rouge, les deux derniers de la composante verte et les trois derniers de la composante bleue. Une fois les trois parties récupérées, il ne reste plus qu'à les mettre bout-à-bout pour retrouver le pixel noir et blanc de l'image dissimulée.&lt;/p&gt;
&lt;p&gt;Voici l'application en C++ :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;  &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;   * Extraire l&amp;#39;image en niveau de gris dissimulée dans une image&lt;/span&gt;
&lt;span class="cm"&gt;   * Il faut appliquer l&amp;#39;algorithme inverse pour retrouver l&amp;#39;image cachée.&lt;/span&gt;
&lt;span class="cm"&gt;   *&lt;/span&gt;
&lt;span class="cm"&gt;   * @param image           [in]  Image stéganographiée&lt;/span&gt;
&lt;span class="cm"&gt;   * @param image_extracted [out] Image en niveau de gris&lt;/span&gt;
&lt;span class="cm"&gt;   */&lt;/span&gt;
  &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;extract&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;ImageUchar&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ImageUchar&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;image_extracted&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// Récupération des trois derniers bits contenus dans le rouge&lt;/span&gt;
        &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;part_1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//0000 0111&lt;/span&gt;

        &lt;span class="c1"&gt;// Récupération des deux derniers bits contenus dans le vert&lt;/span&gt;
        &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;part_2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//0000 0011&lt;/span&gt;

        &lt;span class="c1"&gt;// Récupération des trois derniers bits contenus dans le bleu&lt;/span&gt;
        &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="n"&gt;part_3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;//0000 0111&lt;/span&gt;

        &lt;span class="c1"&gt;// Fusion de part_1, part_2 et part_3 afin de recomposer le niveau de gris original&lt;/span&gt;
        &lt;span class="n"&gt;image_extracted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;part_1&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;part_2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;part_3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Résultat de cet algorithme sur l'image précédemment obtenue. Nous obtenons bien l'image noir et blanc préalablement dissimulée.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="Résumé" src="https://bitbucket.org/TrashZen/trivial-steganography/raw/35131b8d002f5c83360bd5ff411ceeee69bf48ec/doc/resources/resume_extraction.jpg" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;h2&gt;Aller plus loin&lt;/h2&gt;
&lt;p&gt;D'autres techniques similaires existent. Par exemple nous pouvons changer l'espace de colorisation &lt;a href="http://fr.wikipedia.org/wiki/Rouge_vert_bleu"&gt;RVB&lt;/a&gt; (Rouge Vert Bleu) en &lt;a href="http://fr.wikipedia.org/wiki/Teinte_Saturation_Luminosité"&gt;TSL&lt;/a&gt; (Teinte Saturation Luminance) et ainsi modifier la teinte, la saturation et la luminance plutôt que le niveau de rouge, de vert et de bleu.&lt;/p&gt;
&lt;p&gt;L'inconvénient de ces algorithmes est qu'ils ne permettent aucune dégradation de l'image. Le simple fait de compresser l'image en JPEG est susceptible de détruire l'image dissimulée. Cela est dû au format JPEG en lui-même car il est basé sur un algorithme de compression avec perte. Les bits de poids faible vont être modifiés et l'image dissimulée détruite. Le redimensionnement de l'image aura le même effet.&lt;/p&gt;
&lt;p&gt;Pour pallier à ces problèmes, d'autres algorithmes existent, basés sur le domaine fréquentiel. Un algorithme célèbre consiste à appliquer une transformation de Fourier sur notre image, modifier ensuite les fréquences moyennes et effectuer une transformation inverse. &lt;/p&gt;
&lt;p&gt;Pourquoi modifier les fréquences moyennes et pas les autres ?&lt;/p&gt;
&lt;p&gt;Car si nous modifions les fréquences faibles, la première compression venue va détruire l'image dissimulée. Et si nous modifions les fréquences trop hautes, l'image originale va recevoir trop de modifications et la stéganographie sera visible. Voici un article détaillant la &lt;a href="http://www.tsi.telecom-paristech.fr/pages/enseignement/ressources/beti/ondelettes-2g/francais/Fourier/TF2Dimage.htm"&gt;transformée de Fourier&lt;/a&gt; pour approfondir le sujet.&lt;/p&gt;
&lt;p&gt;Si le traitement d'image vous intéresse voici un &lt;a href="http://images.math.cnrs.fr/Le-traitement-numerique-des-images.html"&gt;article intéressant&lt;/a&gt; reprenant les bases nécessaires pour commencer à développer ses propres algorithmes.&lt;/p&gt;
&lt;p&gt;Lien du git avec les sources : &lt;a href="https://bitbucket.org/TrashZen/trivial-steganography/overview"&gt;https://bitbucket.org/TrashZen/trivial-steganography/overview&lt;/a&gt;.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexis François</dc:creator><pubDate>Thu, 26 Sep 2013 00:00:00 +0200</pubDate><guid>tag:www.lab-sl3.org,2013-09-26:articles/news/traitement-dimage-trivial-steganography.html</guid><category>Stéganograpie</category><category>traitement d'image</category></item><item><title>Introduction à l'algorithmique</title><link>http://www.lab-sl3.org/articles/news/introduction-a-lalgorithmique.html</link><description>&lt;p&gt;L'algorithmique est une discipline de résolution de problèmes par de la logique. Les algorithmes sont à la base de tout programme informatique.&lt;br /&gt;
Un algorithme est souvent décrit comme une "recette de cuisine", une procédure à suivre pour obtenir un résultat et c'est ce fonctionnement qui est utilisé dans la plupart des langages de programmation.&lt;/p&gt;
&lt;p&gt;Pourtant, beaucoup de développeurs délaissent en grande partie cet aspect de l'informatique car ils utilisent des outils prêts à l'emploi qui font ce qu'ils ont besoin, tout en cachant la complexité de la résolution du problème.
Effectivement, utiliser ce genre d'outil s'apparente à jouer aux LEGO: on assemble des briques de base pour faire des éléments plus complexes, mais construire ces briques de base est tout aussi intéressant et pas si complexe qu'il n'y paraît!
Parfois, vous obtiendrez même de meilleures performances en créant vos propres briques!&lt;/p&gt;
&lt;p&gt;Une seule chose à faire : réfléchir. (Selon des études poussées et menées par des chercheurs, tout le monde en serait capable :p)&lt;/p&gt;
&lt;h2&gt;Les algorithmes sont partout&lt;/h2&gt;
&lt;p&gt;Imaginez un peu... Vous êtes à SUPINFO, en cours d'algorithmique. C'est une discipline que vous détestez par dessus tout parce que vous ne comprenez jamais rien. On vous demande de trier une liste d'éléments et vous cherchez un algorithme tout fait sur internet("Comme ça, le prof sera content"). Vous interrogez donc un moteur de recherche qui va utiliser &lt;em&gt;son algorithme&lt;/em&gt; pour trouver ce que vous cherchez.&lt;/p&gt;
&lt;p&gt;En rentrant chez vous, vous devez aller faire quelques courses au supermarché du coin. Vous payez par carte bleue et la transaction bancaire se fait grâce à plusieurs algorithmes (&lt;em&gt;interrogation de la banque&lt;/em&gt;, &lt;em&gt;sécurisation des échanges grâce à un cryptage&lt;/em&gt; ...).&lt;/p&gt;
&lt;p&gt;Vous êtes nouveau dans la région et ne savez pas encore rentrer chez vous. Vous allumez donc votre GPS et programmez le plus court chemin pour rentrer chez vous. Après une &lt;em&gt;phase de calcul&lt;/em&gt;, il peut vous guider.&lt;/p&gt;
&lt;p&gt;Une fois chez vous, exténué par tous ces algorithmes qui vous entourent, vous allumez la télévision pour vous détendre un peu. Un candidat à bout de nerfs hurle pour gagner le jeu du &lt;em&gt;"Plus ou moins"&lt;/em&gt;. Finalement, la télévision, ça énerve...&lt;/p&gt;
&lt;p&gt;Alors vous tentez de faire un puzzle, vous commencez par les coins, puis les bords, puis... oh, attendez...&lt;/p&gt;
&lt;p&gt;Énervé, vous envoyez valser un coussin du canapé contre le mur. En retombant, celui-ci fait tomber tous vos précieux albums de Tintin. Vous commencez alors à les remettre sur l'étagère, vous ramassez le premier venu, c'est le numéro 5. Le deuxième est le numéro 4, vous le mettez à sa gauche... GRAAAAAHHHHH, c'est encore un algorithme!&lt;/p&gt;
&lt;p&gt;Attendez! ça ne sert à rien de s'énerver, l'algorithmique ce n'est pas si terrible que ça! La preuve en est que vous l'avez votre algorithme de tri :) C'est un tri par insertion.&lt;/p&gt;
&lt;h2&gt;Un exemple d'algorithme : Le tri par insertion&lt;/h2&gt;
&lt;p&gt;Votre algorithme est vraiment très simple n'est-ce pas? Et pourtant c'en est bien un. C'est également le même algorithme que vous allez utiliser pour trier vos cartes quand vous jouez à la belote, au tarot, au président etc etc...&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="L'algorithme en images" src="https://bitbucket.org/gnoirzox/sl3-content/raw/199814e59d842a1876a7edc987ff17ec31b41922/insertionLivres.png" /&gt;&lt;/center&gt;
&lt;center&gt;&lt;em&gt;Une étape de l'algorithme en image, l'insertion d'un livre au bon emplacement&lt;/em&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Cet algorithme est assez intuitif, mais il faut à présent expliquer comment faire à un ordinateur. Pour celà, il nous faut:
&lt;em&gt; La liste des éléments à trier (= L'amas de livres qui est tombé de l'étagère)
&lt;/em&gt; Une liste qui va contenir les éléments une fois triés (L'étagère)
* Un moyen d'insérer un élément dans la liste finale (Pour insérer un livre sur l'étagère, il faut décaler tous les livres qui ont un numéro supérieur au livre qu'on veut insérer et placer le livre à l'endroit libéré. De la rapidité de cette action dépend la rapidité de l'algorithme.)&lt;/p&gt;
&lt;p&gt;Voici donc une transcription en C++ de notre algorithme:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;list&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;triParInsertion&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;listeLivres&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;etagere&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; 
    &lt;span class="c1"&gt;//Prends en paramètre le tableau à trier et sort en deuxième paramètre le tableau trié&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;const_iterator&lt;/span&gt; &lt;span class="n"&gt;itLivre&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;listeLivres&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="n"&gt;itLivre&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="n"&gt;listeLivres&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="n"&gt;itLivre&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; 
        &lt;span class="c1"&gt;//On parcoure notre amas de livres&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;itEtagere&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//Va contenir l&amp;#39;endroit où on va insérer l&amp;#39;élément.&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;itEtagere&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;etagere&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="n"&gt;itEtagere&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;etagere&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="n"&gt;itEtagere&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
            &lt;span class="c1"&gt;//On parcoure un à un les éléments déjà placés sur l&amp;#39;étagère&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itEtagere&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itLivre&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
                &lt;span class="c1"&gt;//Si on trouve un livre dont le numéro est supérieur au livre qu&amp;#39;on vient de ramasser, &lt;/span&gt;
                &lt;span class="c1"&gt;//on va insérer celà avant&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="cm"&gt;/*Ici, deux cas sont possible.&lt;/span&gt;
&lt;span class="cm"&gt;            -Soit il y a au moins un livre sur l&amp;#39;étagère dont le numéro est supérieur et à ce moment là&lt;/span&gt;
&lt;span class="cm"&gt;             l&amp;#39;itérateur pointe sur le premier de ces éléments. Le insert va insérer avant cet élément&lt;/span&gt;
&lt;span class="cm"&gt;            -Soit il n&amp;#39;y a pas de livre satisfiant cette condition et itEtagere == etagere.end(), &lt;/span&gt;
&lt;span class="cm"&gt;            le insert va insérer à la fin&lt;/span&gt;
&lt;span class="cm"&gt;        */&lt;/span&gt;
        &lt;span class="n"&gt;etagere&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;itEtagere&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itLivre&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;//A la fin, les éléments seront triés dans le bon ordre&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pour ceux qui n'ont jamais fait de C++ ou qui n'ont pas utilisé de listes, sachez simplement qu'un itérateur sert à parcourir un tableau du début à la fin. Il est également utilisé pour certaines autres opérations, comme par exemple l'appel à la méthode insert pour dire à quel endroit on veut insérer l'élément.&lt;/p&gt;
&lt;p&gt;Et voilà, votre algorithme est prêt à être utilisé :)
Malheureusement, il n'est pas toujours possible d'insérer un élément à un endroit donné. Dans certains cas, il faudra faire autrement.&lt;/p&gt;
&lt;h2&gt;Un autre exemple d'algorithme : Le tri par sélection&lt;/h2&gt;
&lt;p&gt;Cette fois-ci, vous avez décidé de vous mettre à faire des perles.
Vous avez à disposition une boite de perles de tailles différentes et un fil.
Vous voulez vous fabriquer un beau collier de perles, de la plus petite à la plus grosse.
Seulement, à la différence de l'étagère, vous ne pouvez pas insérer de perle au milieu.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Hmmm, comment faire?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Réfléchissez un peu...&lt;/p&gt;
&lt;p&gt;Une idée?&lt;/p&gt;
&lt;p&gt;Une solution intuitive consiste à trouver la plus petite perle restante dans la boite et l'ajouter sur le fil.
Recommencer jusqu'à ce que la boite soit vide.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="L'algorithme en images" src="https://bitbucket.org/gnoirzox/sl3-content/raw/199814e59d842a1876a7edc987ff17ec31b41922/insertionPerles.png" /&gt;&lt;/center&gt;
&lt;center&gt;&lt;em&gt;Une étape de l'algorithme en image, l'insertion de la bonne perle au bout du fil&lt;/em&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Et voici une transcription en C++ de cet algorithme :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;list&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;triParSelection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;boite&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;collier&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
    &lt;span class="c1"&gt;//Premier paramètre, la liste d&amp;#39;éléments à trier, deuxième paramètre le collier. &lt;/span&gt;
    &lt;span class="c1"&gt;//Ici, je n&amp;#39;ai pas mis le premier paramètre constant car je vais retirer les éléments de la boite &lt;/span&gt;
    &lt;span class="c1"&gt;//une fois qu&amp;#39;ils sont mis dans le collier&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;boite&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
        &lt;span class="c1"&gt;//Tant que la boite n&amp;#39;est pas vide.&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;itMin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;boite&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;boite&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="n"&gt;boite&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
            &lt;span class="c1"&gt;//On cherche l&amp;#39;élément minimum&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itMin&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
                &lt;span class="c1"&gt;//Si on a trouvé un élément plus petit que le plus petit&lt;/span&gt;
                &lt;span class="n"&gt;itMin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; 
        &lt;span class="c1"&gt;//À noter, cette boucle aurait pu se remplacer &lt;/span&gt;
        &lt;span class="c1"&gt;//par std::list&amp;lt;int&amp;gt; itMin = std::min_element(boite.begin(), boite.end());&lt;/span&gt;
        &lt;span class="n"&gt;collier&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itMin&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//On ajoute la valeur au collier&lt;/span&gt;
        &lt;span class="n"&gt;boite&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;erase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;itMin&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;        &lt;span class="c1"&gt;//On retire l&amp;#39;élément de la boite&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;TADADADAAAAAAAM :) Voilà un beau collier tout prêt :p&lt;/p&gt;
&lt;h2&gt;Encore un exemple : L'exploration de labyrinthe&lt;/h2&gt;
&lt;p&gt;Fier de votre collier, vous décidez d'aller frimer dehors et organiser une sortie entre amis dans le labyrithe de votre région.
Malheureusement, vos compétences en orientation laissent à désirer et vous cherchez un moyen d'être sûr de trouver la sortie facilement.&lt;/p&gt;
&lt;p&gt;Des solutions existent comme par exemple se déplacer "au hasard" ou "à l'intuition" dans le labyrinthe.
Ces deux approches sont similaires mais la deuxième introduit une part de jugement humain qu'il n'est pas facile de transcrire sur un ordinateur.
Malheureusement, ces solutions ne sont pas certaines de donner un résultat dans un temps raisonnable (rien n'empêche de tourner en rond).
Il faut donc trouver autre chose de plus sûr.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="Un exemple de labyrinthe" src="http://upload.wikimedia.org/wikipedia/commons/8/88/Maze_simple.svg" /&gt;&lt;/center&gt;
&lt;center&gt;&lt;em&gt;Source : &lt;a href="http://commons.wikimedia.org/wiki/File:Maze_simple.svg"&gt;Wikipédia&lt;/a&gt;&lt;/em&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Une autre solution est possible, car nous avons un labyrinthe fermé.
Il suffit de longer le mur à gauche dès l'entrée (ou à droite, le résultat est le même).
Vous aurez à un moment (plus ou moins long, certes) atteint la sortie, c'est l'algorithme de la main gauche (ou main droite selon la préférence).
Disposant en tant qu'humain d'une mémoire assez limitée qui peut être facilement trompée (rien ne ressemble plus au carrefour d'un labyrinthe qu'un autre carrefour, ils le font exprès en plus!), c'est la solution que l'on va privilégier dans la vie réelle.
C'est une solution fiable qui ne nécessite pas ou peu de réflexion.&lt;/p&gt;
&lt;p&gt;Cet algorithme qui nous paraît simple, exprimé en tant qu'humain, est pourtant plus difficile à transcrire dans le langage de l'ordinateur
Étant donné que l'ordinateur dispose d'une puissance de calcul et d'une mémoire plus importante qu'un être humain, il va devenir totalement acceptable d'explorer le labyrithe.&lt;/p&gt;
&lt;p&gt;Un ordinateur va pouvoir explorer chaque possibilité à chaque intersection du labyrinthe. Si l'exploration n'aboutit pas (cul-de-sac), on reprend alors la recherche à partir du dernier croisement.&lt;/p&gt;
&lt;p&gt;Voici la liste de ce qu'il nous faut:
&lt;em&gt; Un tableau à deux dimensions qui va représenter notre labyrinthe.
Un # représente un mur, un . un passage et X une case explorée.
La case de départ devra être la seule case marqué d'un X
&lt;/em&gt; Une liste qui va contenir les cases qui n'ont pas été explorées mais qui sont atteignable depuis l'une des cases explorées.&lt;/p&gt;
&lt;p&gt;Voici la transcription du labyrinthe ci-dessus :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;#X###################&lt;/span&gt;
&lt;span class="c"&gt;#.....#.....#.......#&lt;/span&gt;
&lt;span class="c"&gt;#.###.#.###.#.#####.#&lt;/span&gt;
&lt;span class="c"&gt;#.#...#...#...#.#...#&lt;/span&gt;
&lt;span class="c"&gt;#.#######.###.#.#.###&lt;/span&gt;
&lt;span class="c"&gt;#...#...#...#...#.#.#&lt;/span&gt;
&lt;span class="c"&gt;###.#.###.#.#####.#.#&lt;/span&gt;
&lt;span class="c"&gt;#.....#...#...#.....#&lt;/span&gt;
&lt;span class="c"&gt;#.#####.#.#####.#####&lt;/span&gt;
&lt;span class="c"&gt;#.......#...#.......#&lt;/span&gt;
&lt;span class="c"&gt;###################.#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;et un code C++ transcrivant cet algorithme:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stack&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;exception&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Position&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
    &lt;span class="c1"&gt;//Une petite classe utilitaire juste pour stocker les coordonnées X,Y&lt;/span&gt;
    &lt;span class="nl"&gt;public:&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;Position&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;_X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;_Y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_X&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_Y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;laby&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="n"&gt;labyrinthe&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;largeur&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;hauteur&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Position&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//La position, au format (X,Y)&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;posDepartTrouvee&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;hauteur&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
        &lt;span class="c1"&gt;//Recherche du X qui représente la case de départ.&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;largeur&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;labyrinthe&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;X&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
                &lt;span class="c1"&gt;//On a trouvé la case de départ, on interrompt les boucles&lt;/span&gt;
                &lt;span class="n"&gt;posDepartTrouvee&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posDepartTrouvee&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;posDepartTrouvee&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="c1"&gt;//Si on n&amp;#39;a pas trouvé la case de départ, on arrête tout.&lt;/span&gt;
        &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;invalid_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Le labyrinthe doit avoir une case de depart.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Position&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;aParcourir&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//On utilise ici une stack (pile en français), &lt;/span&gt;
    &lt;span class="c1"&gt;//c&amp;#39;est à dire un conteneur LIFO (Dernier arrivé, premier sorti).&lt;/span&gt;

    &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//On est sur une case, 4 choix s&amp;#39;offrent à nous (4 directions). &lt;/span&gt;
        &lt;span class="c1"&gt;//On va regarder parmis ces 4 lesquels sont possibles et libres et les ajouter dans la pile.&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;labyrinthe&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;.&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
            &lt;span class="c1"&gt;//Si on est pas sur le bord de gauche et que la case est libre&lt;/span&gt;
            &lt;span class="c1"&gt;//(pas un mur et pas déjà parcourue)&lt;/span&gt;
            &lt;span class="n"&gt;aParcourir&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Position&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;labyrinthe&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;.&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
            &lt;span class="c1"&gt;//Si on est pas sur le bord du haut et que la case est libre&lt;/span&gt;
            &lt;span class="n"&gt;aParcourir&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Position&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;largeur&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;labyrinthe&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;.&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
            &lt;span class="c1"&gt;//Si on est pas sur le bord de droite et que la case est libre&lt;/span&gt;
            &lt;span class="n"&gt;aParcourir&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Position&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;hauteur&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;labyrinthe&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;.&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
            &lt;span class="c1"&gt;//Si on est pas sur le bord du bas et que la case est libre&lt;/span&gt;
            &lt;span class="n"&gt;aParcourir&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Position&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;aParcourir&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
            &lt;span class="c1"&gt;//On a vraiment tout essayé, pas moyen de sortir du labyrinthe&lt;/span&gt;
            &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;runtime_error&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Impossible de trouver la sortie de ce labyrinthe!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;aParcourir&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;         &lt;span class="c1"&gt;//On se déplace sur une nouvelle case à explorer&lt;/span&gt;
        &lt;span class="n"&gt;labyrinthe&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;X&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//On marque qu&amp;#39;on est passé sur cette case.&lt;/span&gt;
        &lt;span class="n"&gt;aParcourir&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;               &lt;span class="c1"&gt;//On enlève l&amp;#39;élément.&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;largeur&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;hauteur&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
    &lt;span class="c1"&gt;//Tant qu&amp;#39;on est pas sur un bord, on est pas sorti&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Attention, cet algorithme sort du labyrinthe et marque les cases par lesquelles il est passé. Avec un peu de modifications, on pourrait lui faire écrire le chemin de la sortie, mais ce n'était pas l'objectif ici.&lt;/p&gt;
&lt;p&gt;Cet algorithme était un peu plus compliqué que les autres. Prenez le temps de bien le comprendre.
Comment fonctionne-t-il?&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="L'algorithme en images" src="https://bitbucket.org/gnoirzox/sl3-content/raw/199814e59d842a1876a7edc987ff17ec31b41922/maze_solved.svg" /&gt;&lt;/center&gt;
&lt;center&gt;&lt;em&gt;Comparaison de l'algorithme ci-dessus (en vert) et de l'algorithme de la main gauche (en rouge)&lt;/em&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;On commence par trouver la case de départ. Une fois celle-ci trouvée, on commence à parcourir le labyrinthe.&lt;br /&gt;
On regarde toutes les cases autour de la case actuelle et pour ces cases là, on regarde si il est possible de s'y déplacer.&lt;br /&gt;
Si c'est possible, on ajoute la case à la liste des cases à parcourir.
Le fait que cette liste soit une pile nous aide à aller de l'avant. On va d'abord essayer les cases qui ont été trouvées en dernier.&lt;br /&gt;
On recommence donc avec la case suivante (celle qui a été ajoutée en dernier, donc depuis la case précédente).&lt;/p&gt;
&lt;p&gt;Si on trouve un cul-de-sac, on n'ajoute plus de cases à la pile et on va revenir à une case ajoutée avant(c'est à dire revenir à la dernière intersection qui n'a pas été complètement explorée).&lt;/p&gt;
&lt;p&gt;Si il n'y a plus de cases à explorer, cela signifie que le labyrinthe est fermé et qu'il n'y a pas de solution.&lt;/p&gt;
&lt;h2&gt;Méfiez-vous des LEGOS&lt;/h2&gt;
&lt;p&gt;Les briques logicielles déjà toutes faites peuvent s'avérer pratiques, mais parfois il vaut mieux "réinventer la roue" plutôt que de vouloir à tout prix réutiliser une fonction.&lt;/p&gt;
&lt;p&gt;Prenons un exemple. Suite à votre sortie dans le labyrinthe, vous avez réussi à vendre vos créations à une cliente disons... imposante.
Par conséquent, elle souhaite que vous doubliez la taille de vos collier afin qu'elle vous en achète.
Prévoyant, vous aviez fait des réserves de colliers déjà confectionnés sur ce modèle (du plus petit au plus grand), il vous reste juste à en démonter deux pour en faire un seul.
Maintenant que vous avez la technique de montage du collier, vous vous ditez que le plus simple serait de couper les deux colliers, de rassembler les perles dans une boite, de prendre un nouveau fil et de recommencer.
En effet, ça serait plus simple dans le sens où vous n'avez pas besoin de réfléchir sur un nouvel algorithme, mais cette façon de faire vous prendrait donc deux fois plus de temps que pour faire un collier de taille standard (sans compter le temps que vous aviez passé à faire ces deux colliers.)&lt;/p&gt;
&lt;p&gt;Voici l'implémentation en C++ de cette &lt;em&gt;mauvaise&lt;/em&gt; façon de faire:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;boite&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;boite&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;boite&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;collierA&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;collierA&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="n"&gt;boite&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;boite&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;collierB&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;collierB&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;doubleCollier&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;triParSelection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;boite&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;doubleCollier&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Intuitivement, on se rend bien compte qu'il va nous falloir beaucoup de temps pour tout refaire.
Même si ce code est pratique et très lisible, il vaut peut-être mieux trouver une autre solution.
On pourrait utiliser le fait que les deux colliers sont déjà bien faits, et donc que les deux listes sont déjà triées.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Temps de réflexion&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Vous avez trouvé ?&lt;/p&gt;
&lt;p&gt;La technique consiste donc à couper les deux colliers au début (là où se trouvent les perles les plus petites) et à comparer la taille de la perle qui se trouve à l'extrêmité de chacun. La plus petite est retirée pour aller sur le nouveau fil, l'autre reste en place.
On recommence ainsi jusqu'à ce qu'il n'y aie plus de perles à retirer.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;fusionCollier&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;collierA&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;collierB&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;collierFinal&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
    &lt;span class="c1"&gt;//Fusionne les deux colliers collierA et collierB dans collierFinal&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;collierA&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;collierB&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
        &lt;span class="c1"&gt;//Tant que les deux colliers ne sont pas tous les deux vides&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;collierA&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
            &lt;span class="c1"&gt;//Cas particulier, le collier A est vide, &lt;/span&gt;
            &lt;span class="c1"&gt;//il ne reste plus qu&amp;#39;à rajouter tous les éléments de B à la fin du collier final&lt;/span&gt;
            &lt;span class="n"&gt;collierFinal&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;collierFinal&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;collierB&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;collierB&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
            &lt;span class="n"&gt;collierB&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clear&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;collierB&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
            &lt;span class="c1"&gt;//Cas particulier, le collier B est vide, &lt;/span&gt;
            &lt;span class="c1"&gt;//il ne reste plus qu&amp;#39;à rajouter tous les éléments de A à la fin du collier final&lt;/span&gt;
            &lt;span class="n"&gt;collierFinal&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;collierFinal&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;collierA&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;collierA&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
            &lt;span class="n"&gt;collierA&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clear&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
            &lt;span class="c1"&gt;//Il reste au moins un élément dans chaque collier&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;collierA&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;collierB&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="c1"&gt;//La première perle de A est plus petite que la première de B &lt;/span&gt;
                &lt;span class="c1"&gt;//(et donc nécessairement que toutes celles du collier B)&lt;/span&gt;
                &lt;span class="n"&gt;collierFinal&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;collierA&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt; &lt;span class="c1"&gt;//On ajoute notre perle&lt;/span&gt;
                &lt;span class="n"&gt;collierA&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop_front&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//On retire la perle du collier A&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt; 
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
                &lt;span class="c1"&gt;//Même chose si c&amp;#39;est la perle du collier B la plus petite&lt;/span&gt;
                &lt;span class="n"&gt;collierFinal&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;collierB&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
                &lt;span class="n"&gt;collierB&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop_front&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Effectivement, ce code est un petit peu plus long à écrire, mais il est énormément plus rapide. Sur de petits échantillons (une à deux fusions sur des colliers de quelques éléments), la différence ne se voit pas sur un ordinateur, mais pour peu que les colliers contiennent 1000 perles et s'il faut en produire une grande quantité, le ralentissement va commencer à se faire sentir. (Voir fichier zip en bas de cet article)&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;L'algorithmique permet de résoudre pas mal de problèmes qui peuvent se poser.
En réfléchissant un peu, on finit souvent par trouver des bonnes solutions.&lt;/p&gt;
&lt;p&gt;Voici quelques liens pour vous entraîner grâce à des exercices:
&lt;em&gt; &lt;a href="http://www.france-ioi.org/algo/chapters.php"&gt;France IOI&lt;/a&gt;,
&lt;/em&gt; &lt;a href="http://prologin.org/training"&gt;Prologin&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Une applet java vous permettant de visualiser différents algorithmes de tri:
&lt;a href="http://thomas.baudel.name/Visualisation/VisuTri/index.fr.html"&gt;Visualisation de tris&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Une visualisation similaire, mais sous forme de gif:
&lt;a href="http://www.sorting-algorithms.com/"&gt;Visualisation de tris&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Voici une archive qui contient les codes sources de cet article avec des codes de test :
&lt;a href="https://bitbucket.org/gnoirzox/sl3-content/raw/199814e59d842a1876a7edc987ff17ec31b41922/codes_algorithmes.zip"&gt;Codes(Visual studio 2010+ et Code::Blocks)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Et pour finir, un excellent ouvrage pour aller plus loin grâce à des explications claires:
&lt;a href="http://mitpress.mit.edu/books/introduction-algorithms"&gt;Introduction à l'algorithmique - Thomas Cormen, Charles Leiserson, Ronald Rivest, Clifford Stein&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeremy Vignelles</dc:creator><pubDate>Sat, 24 Aug 2013 00:00:00 +0200</pubDate><guid>tag:www.lab-sl3.org,2013-08-24:articles/news/introduction-a-lalgorithmique.html</guid><category>Algorithmique</category><category>Tri</category><category>C++</category></item><item><title>Jouons avec C++11: métaprogrammation et variadic templates</title><link>http://www.lab-sl3.org/articles/news/jouons-avec-c11-metaprogrammation-et-variadic-templates.html</link><description>&lt;p&gt;Aujourd'hui nous allons nous détendre avec un peu de C++, mais pas n'importe
quel C++ ! Nous allons faire du C++11 et nous allons explorer ensemble une
fonctionnalité très intéressante et aux nombreuses possibilités du langage :
les variadic templates.&lt;/p&gt;
&lt;p&gt;Pour donner un avant-goût aux plus impatients, au travers de cet article, nous
allons nous amuser avec notre compilateur afin de lui faire réaliser un
ensemble d'opérations pendant même la phase de compilation. En C++, c'est ce
qui constitue la propriété unique des templates: ils sont évalués à la
compilation et non pas à l'exécution.&lt;/p&gt;
&lt;p&gt;Mais avant de nous lancer tête baissée dans le sujet, il est dans un premier
temps nécessaire de replacer un peu de contexte sur C++11 ainsi que les
templates avant d'attaquer la partie amusante.&lt;/p&gt;
&lt;h2&gt;C++ version 11 ?&lt;/h2&gt;
&lt;p&gt;Rassurez-vous, C++ n'en est pas à sa version 11, mais plutôt à sa troisième
version. 
Petit cours d'histoire pour les retardataires :&lt;/p&gt;
&lt;p&gt;C++ est un langage qui est normalisé et qui dispose donc d'un document complet
de spécification. Bien que les travaux sur celui-ci aient commencés en 1979 par
Bjarne Stroustrup, son créateur, la première normalisation du C++ a eu lieu
en 1998, détenue par l'organisme international ISO. À cette époque, cette 
norme a donné lieu au C++98, pour 1998. S'en est suivi en 2003 un « Technical
Corrigendum » consistant en des corrections mineures du précédent document, qui
a donné naissance au C++98/03, aussi désigné C++03.&lt;/p&gt;
&lt;p&gt;Depuis 2003, aucune nouvelle norme n'a donc été publiée jusqu'en Octobre 2011.
L'année 2011 a marqué un tournant majeur dans le monde et la communauté du C++
car elle a donné lieu à une « renaissance » du langage C++ en formant C++11.
Cette nouvelle norme a apporté un lot important de nouvelles fonctionnalités
au langage parmi lesquelles &lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Les fonctions anonymes (&lt;em&gt;lambda expressions&lt;/em&gt;) ;&lt;/li&gt;
&lt;li&gt;Les boucles de type foreach (&lt;em&gt;for-range based loops&lt;/em&gt;) ;&lt;/li&gt;
&lt;li&gt;L'inférence de type avec le mot-clé &lt;em&gt;auto&lt;/em&gt; ;&lt;/li&gt;
&lt;li&gt;L'apparition de la notion de multi-threading dans la bibliothèque standard ;&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;li&gt;Les &lt;strong&gt;variadic templates&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tout au long de cet article, c'est donc les &lt;strong&gt;variadic templates&lt;/strong&gt; qui vont tout
particulièrement nous intéresser. Mais avant toute chose, commençons par rappeler
à quoi correspondent les templates en C++.&lt;/p&gt;
&lt;h2&gt;Une histoire de généricité&lt;/h2&gt;
&lt;p&gt;En C++, les templates définissent le modèle de généricité du langage. En effet,
l'un des enjeux majeurs lorsqu'on écrit du code est de concevoir son architecture
de sorte à ce qu'elle soit le plus &lt;strong&gt;générique&lt;/strong&gt; possible, c'est à dire que son
fonctionnement soit identique quels que soient les types de données sur lesquels elle
agit. C'est ce que l'on appelle la généricité et c'est le problème qu'adressent
en premier lieu les templates du C++.&lt;/p&gt;
&lt;p&gt;Les templates permettent de définir des &lt;strong&gt;modèles&lt;/strong&gt; de classes ou de fonctions
dont le comportement est identique pour un ensemble fini ou infini de types de
données. 
Un bon exemple serait une fonction &lt;code&gt;max&lt;/code&gt; &lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt; permettant de retourner le maximum
de deux éléments passés en paramètre. Pour des entiers, on aurait donc la fonction
suivante:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Mais cette fonction pourrait tout aussi bien fonctionner sur des éléments à
virgule flottante de type &lt;code&gt;double&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="nf"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;On se rend donc très rapidement compte qu'une telle fonction fonctionne pour 
n'importe quel type pouvant être comparé avec l'opérateur &lt;code&gt;&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Grace aux templates, on peut définir le modèle de fonction suivant :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; 
&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;max est ici un &lt;strong&gt;modèle&lt;/strong&gt; de fonction &lt;strong&gt;générique&lt;/strong&gt; fonctionnant pour n'importe
quel type &lt;strong&gt;T&lt;/strong&gt; pouvant être comparé avec l'opérateur &lt;code&gt;&amp;gt;&lt;/code&gt;. Ce modèle va ensuite
servir au compilateur qui s'occupera automatiquement de générer le code 
spécifique à chaque type. On parle alors &lt;strong&gt;d'instanciation&lt;/strong&gt;. Par exemple, pour
deux éléments de type &lt;code&gt;int&lt;/code&gt;, le compilateur va générer le code suivant :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Le compilateur a donc tout simplement remplacé le type générique de base &lt;strong&gt;T&lt;/strong&gt; 
par le type &lt;strong&gt;int&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Tout comme avec les fonctions, l'une des grandes forces des templates C++ consiste
à pouvoir écrire des modèles de &lt;strong&gt;classes&lt;/strong&gt;. Dans la bibliothèque standard du C++,
un très grand nombre de classes utilisent ce principe et sont en réalité des
classes template comme par exemple &lt;code&gt;std::vector&lt;/code&gt; qui est un conteneur permettant
de stocker un ensemble indéterminé d'éléments de façon contigue en mémoire.
&lt;code&gt;vector&lt;/code&gt; peut-être utilisé avec n'importe quel type pouvant être copié &lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Line 1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Line 2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;On dit que l'expression &lt;code&gt;std::vector&amp;lt;std::string&amp;gt;&lt;/code&gt; &lt;strong&gt;instancie&lt;/strong&gt; un objet &lt;code&gt;vector&lt;/code&gt;
avec le type &lt;code&gt;std::string&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;La syntaxe permettant de déclarer une classe template est rigoureusement la même
que pour une fonction template:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; 
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;FixedBuffer&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nl"&gt;private:&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;buffer_&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Avec ce modèle de classe template, l'expression &lt;code&gt;FixedBuffer&amp;lt;int&amp;gt; buf&lt;/code&gt; génèrera
le code spécifique pour le type &lt;code&gt;int&lt;/code&gt;. Dans cette déclaration, on peut également
remarquer un autre paramètre qui n'est pour sa part pas générique puisqu'il
s'agit d'un simple paramètre template de type size_t &lt;sup id="fnref:4"&gt;&lt;a class="footnote-ref" href="#fn:4" rel="footnote"&gt;4&lt;/a&gt;&lt;/sup&gt;. Cela s'appelle un
paramètre template non-typé (&lt;em&gt;non-type template parameter&lt;/em&gt;) et permet de spécifier
des valeurs constantes à la compilation. Ici le paramètre template non-typé &lt;code&gt;N&lt;/code&gt;
a une valeur par défaut de 100 mais peut-être modifié à la compilation :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;FixedBuffer&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;255&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* buffer fixe de 255 int */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Cependant, un ensemble de restrictions s'appliquent quant à ce genre de paramètre
template. Pas tous les types ne peuvent-être utilisés. Il est par exemple illégal
de déclarer un paramètre template non-typé &lt;code&gt;std::string&lt;/code&gt; :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Wrapper&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// Illégal, S ne peut pas être std::string&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Comme nous venons de le démontrer, les templates constituent une part importante 
du langage C++. 
Cependant, outre l'aspect premier de généricité, les templates, de part leur
nature, offrent des possibilités de &lt;strong&gt;métaprogrammation&lt;/strong&gt; que nous allons nous
empresser de découvrir.&lt;/p&gt;
&lt;h2&gt;Introduction en douceur à la métaprogrammation&lt;/h2&gt;
&lt;p&gt;Après leur conception, il a été découvert par hasard que les templates étaient en
réalité &lt;a href="http://fr.wikipedia.org/wiki/Turing-complet"&gt;turing-complet&lt;/a&gt; signifiant
que toute logique pouvait être exprimée et formalisée grâce aux templates.&lt;/p&gt;
&lt;p&gt;Grace aux templates, des problèmes initialement résolus à l'exécution peuvent
donc être désormais résolus directement à la &lt;strong&gt;compilation&lt;/strong&gt;. Cela peut-être
difficile à croire au début, mais le compilateur est capable de résoudre directement
des problèmes pendant la compilation même. Grace aux templates, il est donc possible
de réaliser des calculs à la compilation. 
Illustrons cela sans plus attendre par un premier exemple.
De manière générale dans les langages de programmation, la fonction mathématique
puissance est représentée par la fonction &lt;code&gt;pow&lt;/code&gt;. Ainsi :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;pow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Une telle fonction s'implémente de manière triviale avec une boucle :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;pow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Cette version calcule donc une puissance durant l'exécution du programme. Pour
notre part, nous allons utiliser des templates pour calculer une puissance
à la &lt;strong&gt;compilation&lt;/strong&gt;. Pour cela, nous allons utiliser la propriété récursive
de la fonction puissance. En effet, formellement, la fonction puissance est
définie ainsi :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;La fonction puissance est donc définie grâce à une récursion qui s'arrête
lorsque l'exposant arrive à 0.&lt;/p&gt;
&lt;p&gt;Essayons donc d'exprimer cette définition en classe template :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Pow&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Pow&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Très simplement, nous avons ici exprimé en classe template la récursion même
(nous avons utilisé une structure au lieu d'une classe pour tirer parti de la 
propriété publique par défaut des éléments d'une structure) &lt;/p&gt;
&lt;p&gt;Il ne reste donc plus qu'à exprimer la fin de la récursion lorsque N atteint
la valeur de 0. Pour cela, nous allons utiliser la &lt;strong&gt;spécialisation template&lt;/strong&gt;.
En effet, les templates peuvent être spécialisés pour certaines valeurs, c'est
à dire que leur comportement peut-être redéfini pour certains types ou certaines
valeurs. Ainsi, nous allons spécialiser notre template &lt;code&gt;Pow&lt;/code&gt; pour la valeur
de &lt;code&gt;N&lt;/code&gt; à 0 :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Pow&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Lorsque &lt;code&gt;N&lt;/code&gt; atteindra la valeur de 0, la récursion template s'arrêtera et la
valeur « retournée » sera ainsi de 1.&lt;/p&gt;
&lt;p&gt;Nous pouvons désormais vérifier que tout fonctionne :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Pow&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Pow&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Pow&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Pow&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pour fonctionner, ce programme doit être compilé avec le support de C++11 car
il utilise le nouveau mot-clé &lt;code&gt;constexpr&lt;/code&gt; permettant de déclarer des valeurs
constantes à la compilation.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Wall&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Werror&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;O2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;pow&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;templates&lt;/span&gt; &lt;span class="n"&gt;pow&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;templates&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;À l'exécution, la valeur 16 est donc bien affichée:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;./pow-templates
&lt;span class="nv"&gt;$ &lt;/span&gt;16
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;En guise de double-vérification, nous allons également vérifier que la constante
16 a bien été calculée à la compilation et a bien été remplacée par le 
compilateur en examinant l'assembleur généré :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;objdump -M intel -d pow-templates
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;La section qui nous intéresse est la portion main de la section .text:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="mi"&gt;00000000004006&lt;/span&gt;&lt;span class="nx"&gt;b0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="mi"&gt;4006&lt;/span&gt;&lt;span class="nx"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;       &lt;span class="mi"&gt;48&lt;/span&gt; &lt;span class="mi"&gt;83&lt;/span&gt; &lt;span class="nx"&gt;ec&lt;/span&gt; &lt;span class="mi"&gt;08&lt;/span&gt;             &lt;span class="nb"&gt;sub&lt;/span&gt;    &lt;span class="nx"&gt;rsp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mh"&gt;0x8&lt;/span&gt;
&lt;span class="mi"&gt;4006&lt;/span&gt;&lt;span class="nx"&gt;b4&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;       &lt;span class="nx"&gt;be&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="mi"&gt;00&lt;/span&gt; &lt;span class="mi"&gt;00&lt;/span&gt; &lt;span class="mi"&gt;00&lt;/span&gt;          &lt;span class="nx"&gt;mov&lt;/span&gt;    &lt;span class="nx"&gt;esi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mh"&gt;0x10&lt;/span&gt;
&lt;span class="mi"&gt;4006&lt;/span&gt;&lt;span class="nx"&gt;b9&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;       &lt;span class="nx"&gt;bf&lt;/span&gt; &lt;span class="mi"&gt;60&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="mi"&gt;60&lt;/span&gt; &lt;span class="mi"&gt;00&lt;/span&gt;          &lt;span class="nx"&gt;mov&lt;/span&gt;    &lt;span class="nx"&gt;edi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mh"&gt;0x601060&lt;/span&gt;
&lt;span class="mi"&gt;4006&lt;/span&gt;&lt;span class="nx"&gt;be&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;       &lt;span class="nx"&gt;e8&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="nb"&gt;d&lt;/span&gt; &lt;span class="nx"&gt;ff&lt;/span&gt; &lt;span class="nx"&gt;ff&lt;/span&gt; &lt;span class="nx"&gt;ff&lt;/span&gt;          &lt;span class="nb"&gt;call&lt;/span&gt;   &lt;span class="mi"&gt;400650&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;_ZNSolsEi&lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="nx"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="mi"&gt;4006&lt;/span&gt;&lt;span class="nx"&gt;c3&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;       &lt;span class="mi"&gt;48&lt;/span&gt; &lt;span class="mi"&gt;89&lt;/span&gt; &lt;span class="nx"&gt;c7&lt;/span&gt;                &lt;span class="nx"&gt;mov&lt;/span&gt;    &lt;span class="nx"&gt;rdi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;rax&lt;/span&gt;
&lt;span class="mi"&gt;4006&lt;/span&gt;&lt;span class="nx"&gt;c6&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;       &lt;span class="nx"&gt;e8&lt;/span&gt; &lt;span class="nx"&gt;d5&lt;/span&gt; &lt;span class="nx"&gt;ff&lt;/span&gt; &lt;span class="nx"&gt;ff&lt;/span&gt; &lt;span class="nx"&gt;ff&lt;/span&gt;          &lt;span class="nb"&gt;call&lt;/span&gt;   &lt;span class="mi"&gt;4006&lt;/span&gt;&lt;span class="nx"&gt;a0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_&lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="nx"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="mi"&gt;4006&lt;/span&gt;&lt;span class="nx"&gt;cb&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;       &lt;span class="mi"&gt;31&lt;/span&gt; &lt;span class="nx"&gt;c0&lt;/span&gt;                   &lt;span class="nx"&gt;xor&lt;/span&gt;    &lt;span class="nx"&gt;eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;eax&lt;/span&gt;
&lt;span class="mi"&gt;4006&lt;/span&gt;&lt;span class="nx"&gt;cd&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;       &lt;span class="mi"&gt;48&lt;/span&gt; &lt;span class="mi"&gt;83&lt;/span&gt; &lt;span class="nx"&gt;c4&lt;/span&gt; &lt;span class="mi"&gt;08&lt;/span&gt;             &lt;span class="nb"&gt;add&lt;/span&gt;    &lt;span class="nx"&gt;rsp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mh"&gt;0x8&lt;/span&gt;
&lt;span class="mi"&gt;4006&lt;/span&gt;&lt;span class="nx"&gt;d1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;       &lt;span class="nx"&gt;c3&lt;/span&gt;                      &lt;span class="nx"&gt;ret&lt;/span&gt;
&lt;span class="mi"&gt;4006&lt;/span&gt;&lt;span class="nx"&gt;d2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;       &lt;span class="mi"&gt;66&lt;/span&gt; &lt;span class="mi"&gt;66&lt;/span&gt; &lt;span class="mi"&gt;66&lt;/span&gt; &lt;span class="mi"&gt;66&lt;/span&gt; &lt;span class="mi"&gt;66&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="nx"&gt;e&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="nb"&gt;f&lt;/span&gt;    &lt;span class="nx"&gt;data32&lt;/span&gt; &lt;span class="nx"&gt;data32&lt;/span&gt; &lt;span class="nx"&gt;data32&lt;/span&gt; &lt;span class="nx"&gt;data32&lt;/span&gt; &lt;span class="nx"&gt;nop&lt;/span&gt; &lt;span class="nx"&gt;WORD&lt;/span&gt; &lt;span class="nx"&gt;PTR&lt;/span&gt; &lt;span class="nx"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;rax&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nx"&gt;rax&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;
4006d9:       1f 84 00 00 00 00 00jk
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;À la deuxième ligne, on retrouve donc bel et bien notre constante 16 exprimée
en hexadécimal &lt;code&gt;0x10&lt;/code&gt; qui est placée dans le registre &lt;code&gt;esi&lt;/code&gt;. Le compilateur
a donc bel et bien calculé &lt;code&gt;2^4&lt;/code&gt; à la compilation, fantastique !&lt;/p&gt;
&lt;p&gt;Cet exemple, bien que simple dans l'esprit a donc permis de démontrer les techniques
de base pour pouvoir effectuer des calculs et opérations à la compilation en 
utilisant les templates et la « récursivité ».&lt;/p&gt;
&lt;p&gt;Nous sommes donc désormais prêts à passer aux choses sérieuses et commencer à s'amuser
avec les variadic templates&lt;/p&gt;
&lt;h2&gt;Des templates infinis : les variadic templates&lt;/h2&gt;
&lt;p&gt;Voilà enfin venu le moment que vous attendiez impatiemment depuis le début de cet
article. Ça a été long mais nous y sommes arrivés. Nous allons enfin pouvoir
commencer à nous amuser pour de bon.&lt;/p&gt;
&lt;p&gt;Jusqu'à présent, nos fonctions et classes templates comportaient un nombre fini
et déterminé de paramètres templates. Par exemple, la fonction &lt;code&gt;Pow&lt;/code&gt; acceptait
deux paramètres templates. &lt;/p&gt;
&lt;p&gt;Une classe de la bibliothèque standard comme &lt;code&gt;std::map&lt;/code&gt; accepte quatre paramètres
templates: le type de la clé, le type de la valeur, la fonction de comparaison
permettant de comparer les éléments de la structure entre eux pour pouvoir
déterminer où les placer (map est une structure de type arbre rouge-noir) et
enfin l'allocateur dont le rôle est d'allouer les éléments en mémoire. &lt;/p&gt;
&lt;p&gt;Tout cela pour dire qu'avant C++11, le nombre de paramètres templates devait être
fini et connu à l'avance. C++11 a donc apporté une révision majeure aux templates
en proposant des templates au nombre d'éléments infinis du nom de &lt;strong&gt;variadic
templates&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Dans la bibliothèque, un des bénéfices des variadic templates se trouve avec la
classe &lt;code&gt;std::tuple&lt;/code&gt;  représentant une collection hétérogène de valeurs:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tuple&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Matrix3D&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Le type &lt;code&gt;Matrix3D&lt;/code&gt; ci-dessus est donc un synonyme de type (&lt;code&gt;typedef&lt;/code&gt;) pour un
&lt;code&gt;tuple&lt;/code&gt; de quatres éléments. Le premier élément du tuple est de type &lt;code&gt;std::string&lt;/code&gt;
et le reste du tuple est de type &lt;code&gt;double&lt;/code&gt;.
Grace aux variadics templates, il est possible de stoquer un nombre indéfini
de valeurs dans un &lt;code&gt;tuple&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;La syntaxe proposée par C++11 pour définir une classe ou fonction template
variadic consiste à utiliser l'opérateur ellipse &lt;code&gt;...&lt;/code&gt;. Cet opérateur étant
déjà utilisé pour les fonctions (par exemple &lt;code&gt;printf&lt;/code&gt;), il a été repris pour les
templates:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;Types&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Tuple&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;typename ...Types&lt;/code&gt; est ainsi désigné un &lt;em&gt;template parameter pack&lt;/em&gt; car il accepte
zéro ou plusieurs paramètres templates. Un template variadic est donc un template avec
au moins un &lt;em&gt;template parameter pack&lt;/em&gt;.  &lt;/p&gt;
&lt;p&gt;Ces &lt;em&gt;packs&lt;/em&gt; de paramètres templates regroupant un ensemble de types sous un seul
nom, ceux-ci peuvent être « étendus » grâce au même opérateur ellipse &lt;code&gt;...&lt;/code&gt; et
des règles bien précises. Le tableau ci-dessous résume les règles « d'extension »
des &lt;em&gt;parameter packs&lt;/em&gt; :&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Expression&lt;/th&gt;
&lt;th&gt;Expansion&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Types...&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Type1, Type2, Type3, ..., TypeN&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;tuple&amp;lt;Types...&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;tuple&amp;lt;Type1, Type2, ..., TypeN&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vector&amp;lt;Types&amp;gt;...&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;vector&amp;lt;Type1&amp;gt;, vector&amp;lt;Type2&amp;gt;, ..., vector&amp;lt;Type3&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Comme l'on peut le constater, le placement de l'opérateur ellipse &lt;code&gt;...&lt;/code&gt; peut
radicalement changer les règles d'extension des &lt;em&gt;template parameter packs&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Sans plus attendre, commençons par nous lancer en douceur dans la métaprogrammation
avec les variadic templates.&lt;/p&gt;
&lt;h3&gt;Échauffement: calcul d'une somme de nombres à la compilation&lt;/h3&gt;
&lt;p&gt;Pour nous échauffer sans trop nous brusquer, nous allons commencer par un exemple
rudimentaire. Il est à noter que les exemples qui suivront nécessitent un compilateur
suffisamment récent pour implémenter l'ensemble des fonctionnalités. La version minimale
de gcc devant être utilisée est la version &lt;code&gt;4.7&lt;/code&gt;.
Nous allons donc dans un premier temps écrire un programme template permettant
de calculer la somme d'un ensemble de nombres entiers à la compilation de sorte 
à ce que l'assertion suivante soit vérifiée &lt;sup id="fnref:5"&gt;&lt;a class="footnote-ref" href="#fn:5" rel="footnote"&gt;5&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Sum&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
              &lt;span class="s"&gt;&amp;quot;Somme invalide&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pour réussir cette implémentation, il est dans un premier temps nécessaire
d'établir la relation de récursion d'une somme. Nous sommes chanceux car pour 
une somme, la récursion se définit de manière assez trivale:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;Sum&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Sum&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="n"&gt;Sum&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Sum&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="n"&gt;Sum&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;En généralisant, la récursion devient la suivante:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;Sum&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;Head&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Tail&lt;/span&gt;&lt;span class="p"&gt;...])&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Head&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Sum&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;Tail&lt;/span&gt;&lt;span class="p"&gt;...])&lt;/span&gt;
&lt;span class="n"&gt;Sum&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;Last&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Last&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;Head&lt;/code&gt; représente la tête de liste et &lt;code&gt;Tail...&lt;/code&gt; le reste des éléments de 
la liste. La technique consiste donc à séparer les éléments d'une liste en
un couple d'éléments &lt;code&gt;[Head, Tail...]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Commençons par définir notre &lt;em&gt;variadic template&lt;/em&gt;:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;Numbers&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;SumImpl&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Les détails des implémentations seront gardés dans des structures au
suffixe &lt;code&gt;Impl&lt;/code&gt;. &lt;code&gt;SumImpl&lt;/code&gt; accepte donc en guise de paramètre template un ensemble
de nombres de type &lt;code&gt;int&lt;/code&gt;. 
Ceci étant fait, tâchons désormais d'exprimer notre récursion. Dans l'état actuel,
des éléments sont manquants. En effet, pour exprimer la récursion template, nous
avons besoin de la tête de liste ainsi que du reste des éléments. Pour cela, rien
de plus simple. Nous allons, une fois de plus, spécialiser notre &lt;em&gt;variadic template&lt;/em&gt;
pour « découper » un pack de paramètres templates &lt;code&gt;int ...Numbers&lt;/code&gt; en un
couple &lt;code&gt;int Head, int ...Tail&lt;/code&gt; :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Head&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;Tail&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;SumImpl&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Head&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Tail&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Head&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;SumImpl&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Tail&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;À chaque étape de la récursion, on refait donc appel à &lt;code&gt;SumImpl&lt;/code&gt; en étendant le 
&lt;em&gt;pack parameter&lt;/em&gt; &lt;code&gt;Tail...&lt;/code&gt; afin de le re-diviser en couple &lt;code&gt;Head, Tail...&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Il ne nous reste plus qu'à exprimer la condition d'arrêt de notre récursion, lorsque
la liste une fois étendue ne contient plus qu'un élément. Une fois encore, nous
allons spécialiser notre template :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Last&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;SumImpl&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Last&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Last&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ce qui conclut notre implémentation. Une fois étendue, dès lors que la liste atteindra
son dernier élément, la valeur de celui-ci sera « retournée » et la récursion prendra
fin. Les valeurs précédemment calculées pourront donc être ajoutées les unes
à la suite des autres, et tout cela à la compilation.&lt;/p&gt;
&lt;p&gt;Pour disposer d'une implémentation complète, il ne nous reste plus qu'une dernière
chose à réaliser: étendre les éléments au tout début de la récursion pour
débuter la récursion.
Pour cela, nous allons une fois de plus utiliser une nouvelle fonctionnalité
de C++11 permettant de définir des synonymes templates (&lt;em&gt;templates aliases&lt;/em&gt;) grâce
à la directive using :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;Numbers&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;Sum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SumImpl&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Numbers&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;L'implémentation complète est la suivante :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;Numbers&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;SumImpl&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Head&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;Tail&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;SumImpl&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Head&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Tail&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Head&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;SumImpl&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Tail&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Last&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;SumImpl&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Last&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Last&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;Numbers&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;Sum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SumImpl&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Numbers&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Sum&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
              &lt;span class="s"&gt;&amp;quot;Somme invalide&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;Sum&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Encore une fois, on peut s'amuser à désassambler le binaire final pour vérifier
que l'expression &lt;code&gt;Sum&amp;lt;1, 2, 3, 4, 5&amp;gt;::value&lt;/code&gt; a bien été remplacée à la
compilation par la valeur constante 15:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;objdump -M intel -d sum-templates

0000000000400690 &amp;lt;main&amp;gt;:
400690:       48 83 ec 08             sub    rsp,0x8
400694:       be 0f 00 00 00          mov    esi,0xf
400699:       bf 00 0c 60 00          mov    edi,0x600c00
40069e:       e8 8d ff ff ff          call   400630 &amp;lt;_ZNSolsEi@plt&amp;gt;
4006a3:       48 89 c7                mov    rdi,rax
4006a6:       e8 d5 ff ff ff          call   400680 &amp;lt;_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_@plt&amp;gt;
4006ab:       31 c0                   xor    eax,eax
4006ad:       48 83 c4 08             add    rsp,0x8
4006b1:       c3                      ret
4006b2:       66 66 66 66 66 2e 0f    data32 data32 data32 data32 nop WORD PTR cs:&lt;span class="o"&gt;[&lt;/span&gt;rax+rax*1+0x0&lt;span class="o"&gt;]&lt;/span&gt;
4006b9:       1f 84 00 00 00 00 00
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;C'est bel et bien le cas, la valeur 15 exprimée en hexadémical &lt;code&gt;0xf&lt;/code&gt; a bien été
calculée par le compilateur, il n'a pas fini de nous étonner ! &lt;/p&gt;
&lt;p&gt;Grace à ce premier exemple, on a donc pu appréhender les techniques de base pour
jouer avec les variadic templates. Intéressons-nous maintenant à un exemple plus
utile et réel&lt;/p&gt;
&lt;h3&gt;Cas-réel : inversion de bits d'un nombre intégral&lt;/h3&gt;
&lt;p&gt;Certains algorithmes (par exemple de somme de contrôle) nécessitent de travailler
directement sur les valeurs binaires. Ce cas concrêt va consister à fournir
une implémentation permettant d'inverser un nombre indéterminé de bits d'une
donnée entière, de sorte à pouvoir écrire le code suivant :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;140&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;flip_bits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Au terme de la compilation, les bits numéro 1, 5 et 8 de value seront donc inversés.&lt;/p&gt;
&lt;p&gt;Nous allons dans un premier temps commencer par les préparatifs. Pour réussir
cette implémentation, il nous faut déjà trouver comment inverser un certain bit
d'un ou plusieurs octets. Rien de plus facile. Parmi l'ensemble des fonctions
binaires, la fonction &lt;code&gt;xor&lt;/code&gt; réalise un ou exclusif. En C++, le ou exclusif se
réalise avec l'opérateur &lt;code&gt;^&lt;/code&gt;. Pour comprendre l'intérêt de cette fonction, 
commençons par regarder la table de vérité du ou exclusif:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;A&lt;/th&gt;
&lt;th&gt;B&lt;/th&gt;
&lt;th&gt;A ^ B&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;La fonction ou exclusif retourne 0 si les deux bits sont identiques. En se basant
sur la table de vérité, on comprend que pour inverser un bit N d'un octet, il
suffit de faire un ou exclusif avec la valeur 1.&lt;/p&gt;
&lt;p&gt;Grace à cela, on peut commencer à écrire une fonction simple permettant d'inverser
un simple bit N d'une série d'octets :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;Bit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;is_integral&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;
&lt;span class="n"&gt;flip_bit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Data&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Bit&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;CHAR_BIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="s"&gt;&amp;quot;Bit number out of range&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;^=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;Bit&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ce premier fragment de code est légèrement plus complexe que ce à quoi l'on
aurait pu s'attendre. Décortiquons ensemble les pièces du puzzle en commençant
par le cryptique type de retour :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;enable_if&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;is_integral&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ceci est une pratique habituelle de méta-programmation permettant &lt;strong&gt;d'activer&lt;/strong&gt;
la fonction à la compilation selon une certaine condition. La condition en
question est ici exprimée par&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;is_integral&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;std::is_integral&lt;/code&gt; est ce que l'on appelle une &lt;strong&gt;classe de traits&lt;/strong&gt;. En C++, cela
désigne une classe (ou structure) qui permet d'associer des informations sur un
autre type. En l'occurence, le trait &lt;code&gt;is_integral&lt;/code&gt; permet d'associer l'information
suivante au type:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;Le&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;est&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;il&lt;/span&gt; &lt;span class="n"&gt;un&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="err"&gt;é&lt;/span&gt;&lt;span class="n"&gt;gral&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;Un&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;est&lt;/span&gt; &lt;span class="n"&gt;consid&lt;/span&gt;&lt;span class="err"&gt;é&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="err"&gt;é&lt;/span&gt; &lt;span class="n"&gt;comme&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="err"&gt;é&lt;/span&gt;&lt;span class="n"&gt;gral&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;il&lt;/span&gt;
&lt;span class="n"&gt;fait&lt;/span&gt; &lt;span class="n"&gt;partie&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;liste&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Souhaitant restreindre notre fonction aux types entiers uniquement, nous la rendons
visible grâce à &lt;code&gt;std::enable_if&lt;/code&gt; uniquement si le type de &lt;code&gt;Data&lt;/code&gt; est intégral.
Si &lt;code&gt;Data&lt;/code&gt; n'est pas intégral, la fonction sera « supprimée » et ne pourra pas être
appelée, provoquant une erreur à la compilation. Sinon, elle retournera &lt;code&gt;void&lt;/code&gt;.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Bit&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;CHAR_BIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;Bit number out of range&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;L'assertion statique permet ensuite de vérifier, à la compilation, que le Bit
transmis n'est pas hors des limites. Cette assertion fonctionne en vérifiant que
le numéro du bit transmis est bien inférieur au nombre total de bits du type
&lt;code&gt;Data&lt;/code&gt;. Le nombre total de bits est récupéré en multipliant la taille du type
&lt;code&gt;Data&lt;/code&gt; en byte (retourné par l'opérateur &lt;code&gt;sizeof&lt;/code&gt;) par le nombre de bits présents
dans un byte (représenté par la constante &lt;code&gt;CHAR_BIT&lt;/code&gt;).
En cas de dépassement, un message d'erreur sera émis à la compilation. Cela
constitue également un avantage à la méta-programmation: pouvoir effectuer des
vérifications &lt;strong&gt;pendant&lt;/strong&gt; la compilation et ainsi signaler les erreurs au plus
tôt.&lt;/p&gt;
&lt;p&gt;À partir de cette base, nous allons commencer à bâtir notre récursion. Pour
cela, nous allons écrire un template variadic &lt;code&gt;FlipBitsImpl&lt;/code&gt; qui comportera
une méthode statique &lt;code&gt;flip&lt;/code&gt; comportant la logique de la récursion :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;Bit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;Rest&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;FlipBitsImpl&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;flip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Data&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;flip_bit&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Bit&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;FlipBitsImpl&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Rest&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;flip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;À chaque tour de récursion, on inverse donc le bit courant grâce à la fonction
que nous venons d'écrire puis on continue la récursion avec le reste des
bits en étendant le pack de paramètres &lt;code&gt;Rest...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Finissons donc notre implémentation par la condition d'arrêt de la récursion
lorsque le dernier bit est atteint:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;Bit&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;FlipBitsImpl&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Bit&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;flip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Data&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;flip_bit&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Bit&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Un dernier synonyme template pour cacher l'implémentation et le tour est joué :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;Bits&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;FlipBits&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FlipBitsImpl&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Bits&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Mais ce n'est pas encore complètement terminé. Pour enfin compléter l'implémentation,
il nous reste une dernière chose à faire: fournir une fonction qui sera plus pratique
qu'appeler nous-même le template:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;Bits&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="n"&gt;flip_bits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Data&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;FlipBits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Bits&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;flip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;L'avantage de la fonction est que le type de &lt;code&gt;Data&lt;/code&gt; sera automatiquement déduit &lt;sup id="fnref:6"&gt;&lt;a class="footnote-ref" href="#fn:6" rel="footnote"&gt;6&lt;/a&gt;&lt;/sup&gt;
par le compilateur, évitant ainsi d'avoir à le spécifier soit-même lors de
l'appel à la fonction &lt;code&gt;flip_bits&lt;/code&gt; et au template &lt;code&gt;FlipBits&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Assez cool non ? Auriez-vous imaginé pouvoir faire tout cela à la compilation ?
Et bien c'est maintenant chose faite. &lt;/p&gt;
&lt;p&gt;Mais attendez, vous en voulez encore ? Allez, je vous l'accorde, un petit dernier
pour la route.&lt;/p&gt;
&lt;h3&gt;Conversion binaire&lt;/h3&gt;
&lt;p&gt;Puisqu'on y est, nous allons rester dans le binaire mais nous allons cette fois-ci
essayer de convertir un nombre binaire en décimal à la compilation. Cet exemple
sera sans doute le plus complexe, il faudra donc faire un dernier effort.&lt;/p&gt;
&lt;p&gt;Le C++ ne donnant pas la possibilité d'écrire des constantes binaires du style
&lt;code&gt;0b1000101&lt;/code&gt;, nous allons nous même faire notre propre mécanisme pour contourner
cela. Et devinez quoi ? Nous allons utiliser les variadic templates, une fois
de plus. Cependant, nous allons rajouter une difficulté supplémentaire car, après
tout, on commence à être à l'aise.
Attention, ça va aller très vite. À la fin, notre implémentation devra permettre
de ne pas déclencher les assertions suivantes :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BinaryConverter&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0b != 0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BinaryConverter&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0111b != 7&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BinaryConverter&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1011b != 11&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BinaryConverter&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0b != 0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BinaryConverter&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0111b != 7&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BinaryConverter&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1011b != 11&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vous êtes prêts ? C'est parti.&lt;/p&gt;
&lt;p&gt;Cette fois-ci, notre approche va être légèrement différente. Pour calculer le
résultat, nous allons au fur et à mesure passer le résultat intermédiaire 
à l'intérieur d'un paramètre template :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="n"&gt;Result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;Vals&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Vals&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;digits&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; 
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;BinaryConverterBase&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Le premier paramètre template correspond donc au résultat qui sera progressivement
calculé pendant la récursion. le second paramètre correspond au type des valeurs
qui vont suivre (&lt;code&gt;int&lt;/code&gt; ou &lt;code&gt;char&lt;/code&gt;) et le dernier paramètre est un pack de paramètres
désignant les valeurs des bits à convertir.&lt;/p&gt;
&lt;p&gt;D'autre part, nous avons utilisé la notation &lt;code&gt;BinaryConverterBase&lt;/code&gt; plutôt que
&lt;code&gt;BinaryConverterImpl&lt;/code&gt; pour une raison bien particulière que nous verrons à la fin.&lt;/p&gt;
&lt;p&gt;La récursion va demander quelques éléments supplémentaires. Tout d'abord, toujours
dans notre optique de sécurité, nous souhaitons vérifier qu'aucun chiffre non-binaire
autre que &lt;code&gt;0&lt;/code&gt; ou &lt;code&gt;1&lt;/code&gt; n'est passé en paramètre. Pour cela, nous allons écrire une
fonction &lt;code&gt;is_binary&lt;/code&gt; retournant un booléen indiquant si la valeur est booléenne
ou non. Manipulant des entiers aussi bien que des caractères, nous allons respectivement
avoir besoin de deux surcharges de cette fonction. Enfin, pour séparer les logiques,
nous allons garder cela dans un espace de noms séparé &lt;code&gt;details&lt;/code&gt; :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;details&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;is_binary&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;is_binary&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;is_binary&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pour une valeur de type &lt;code&gt;char&lt;/code&gt;, nous utilisons le fait qu'en C++ il est garanti
que l'expression suivante soit vrai: &lt;code&gt;'0' + 1 == '1'&lt;/code&gt; pour convertir le 
caractère en chiffre.&lt;/p&gt;
&lt;p&gt;Enfin, nous allons également avoir besoin d'un utilitaire de « conversion » pour
convertir une valeur de type &lt;code&gt;char&lt;/code&gt; &lt;code&gt;'0'&lt;/code&gt; en valeur décimale &lt;code&gt;0&lt;/code&gt; et &lt;code&gt;'1'&lt;/code&gt; en &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Pour cela, nous allons écrire un utilitaire template et fournir deux spécialisations
pour les types &lt;code&gt;char&lt;/code&gt; et &lt;code&gt;int&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;details&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;DigitValue&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;DigitValue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;DigitValue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;is_binary&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;is_binary&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;is_binary&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Nous sommes désormais prêts à implémenter notre récursion. Comme d'habitude, nous
découpons notre pack de paramètres templates en couple &lt;code&gt;Head&lt;/code&gt;, &lt;code&gt;Tail...&lt;/code&gt; pour
pouvoir agir sur la tête de liste et continuer la récursion avec le reste :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="n"&gt;Result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;Vals&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Vals&lt;/span&gt; &lt;span class="n"&gt;Head&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Vals&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;Tail&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; 
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;BinaryConverterBase&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Vals&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Head&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Tail&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;details&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;is_binary&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Head&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Encoutered a non-binary value (must be either 0 or 1)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BinaryConverterBase&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Result&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;details&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DigitValue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Vals&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Head&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; 
                                                          &lt;span class="n"&gt;Vals&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Tail&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;À chaque étape de récursion, nous nous efforçons également de vérifier que la valeur
est bien binaire grâce à notre fonction &lt;code&gt;is_binary&lt;/code&gt;. D'autre part, nous utilisons
notre utilitaire template &lt;code&gt;DigitValue&lt;/code&gt; pour récupérer la valeur décimale correspondante
à la valeur du bit en cours. Dans le cas où la valeur traitée est entière, elle
est retournée telle quelle. Dans le cas contraire, s'il s'agit d'une valeur de
type &lt;code&gt;char&lt;/code&gt;, elle est convertie en utilisant le même mécanisme que pour &lt;code&gt;is_binary&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;L'étape finale de la récursion s'arrête lorsque tous les nombres ont été
« consommés », auquel cas le résultat correspond à la valeur finale :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="n"&gt;Result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;Vals&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;BinaryConverterBase&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Vals&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Il ne nous reste donc plus qu'à débuter la récursion. Cependant, cette fois-ci
nous n'allons pas utiliser de synonyme template avec la directive &lt;code&gt;using&lt;/code&gt; mais
une relation simple d'héritage :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;digits&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;BinaryConverter&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; 
&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;BinaryConverterBase&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;remove_cv&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;digits&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;remove_cv&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;is_same&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;is_same&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                  &lt;span class="s"&gt;&amp;quot;Supported types are int and char&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Tout cela pour la simple et bonne raison que nous avons besoin de mettre une
machinerie template supplémentaire. La subtilité se trouve dans la ligne suivante:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;remove_cv&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;std::remove_cv&lt;/code&gt; fait également partie des classes de trait de la bibliothèque standard
du langage dont le but est de tout simplement supprimer les qualificateurs
&lt;code&gt;const&lt;/code&gt; et &lt;code&gt;volatile&lt;/code&gt; d'un type T, permettant ainsi de transformer &lt;code&gt;const int&lt;/code&gt;
en &lt;code&gt;int&lt;/code&gt; et &lt;code&gt;const char&lt;/code&gt; en &lt;code&gt;char&lt;/code&gt;. Cela nous permet de « normaliser » le type
et vérifier à la compilation qu'il s'agit bien d'un entier &lt;code&gt;int&lt;/code&gt; ou &lt;code&gt;char&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Mais ne nous arrêtons pas en si bon chemin. Précédemment, nous avons dit que C++
n'autorisait pas à écrire des constantes binaires du type &lt;code&gt;0b110101&lt;/code&gt;. Cependant,
C++11 a introduit une nouvelle fonctionnalité du nom de &lt;em&gt;user defined literals&lt;/em&gt;
permettant d'ajouter des suffixes personnalisés à des valeurs litérales constantes
pour calculer une certaine valeur.&lt;/p&gt;
&lt;p&gt;Nous pouvons utiliser cette nouvelle fonctionnalité pour nous même implémenter
les constantes litérales binaires en C++, de sorte à pouvoir écrire :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10011101&lt;/span&gt;&lt;span class="n"&gt;_b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Le suffixe &lt;code&gt;_b&lt;/code&gt; indiquant une valeur binaire. Pour cela, il suffit de fournir
un opérateur un peu spécial :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;digits&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;_b&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;BinaryConverter&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;digits&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ainsi, lorsque nous écrirons &lt;code&gt;10011101_b&lt;/code&gt;, la fonction &lt;code&gt;operator "" _b&lt;/code&gt; sera 
invoquée et nous pourrons utiliser notre machinerie de conversion binaire à
la compilation pour réaliser le calcul. Impressionnant, n'est-ce pas ?&lt;/p&gt;
&lt;p&gt;Voici donc le programme complet :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;type_traits&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;cassert&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;details&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;DigitValue&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;DigitValue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;DigitValue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;is_binary&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;is_binary&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;is_binary&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="n"&gt;Result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;Vals&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Vals&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;digits&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;BinaryConverterBase&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="n"&gt;Result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;Vals&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Vals&lt;/span&gt; &lt;span class="n"&gt;Head&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Vals&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;Tail&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; 
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;BinaryConverterBase&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Vals&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Head&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Tail&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;details&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;is_binary&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Head&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Encoutered a non-binary value (must be either 0 or 1)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BinaryConverterBase&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Result&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;details&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DigitValue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Vals&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Head&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; 
                                                          &lt;span class="n"&gt;Vals&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Tail&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="n"&gt;Result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;Vals&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;BinaryConverterBase&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Vals&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;digits&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;BinaryConverter&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; 
    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;BinaryConverterBase&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;remove_cv&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;digits&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;remove_cv&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;is_same&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;is_same&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                  &lt;span class="s"&gt;&amp;quot;Supported types are int and char&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="n"&gt;digits&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;_b&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;BinaryConverter&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;digits&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BinaryConverter&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0b != 0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BinaryConverter&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0111b != 7&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BinaryConverter&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1011b != 11&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BinaryConverter&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0b != 0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BinaryConverter&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0111b != 7&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;static_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BinaryConverter&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1011b != 11&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mo"&gt;0111&lt;/span&gt;&lt;span class="n"&gt;_b&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;0x7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;11111111&lt;/span&gt;&lt;span class="n"&gt;_b&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;0xFF&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10101010&lt;/span&gt;&lt;span class="n"&gt;_b&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;0xAA&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Cette fois-ci, je vous laisse vérifier par vous-même l'assembleur généré par le
compilateur&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Au travers de divers exemples, nous avons donc pu explorer les possibilités de
méta-programmation offertes par les templates du C++. Outre l'aspect générécité,
nous avons donc pu voir que les templates pouvaient servir à écrire et 
générer du code à la compilation.&lt;/p&gt;
&lt;p&gt;De plus, C++11 et les &lt;em&gt;variadic templates&lt;/em&gt; ont permis d'étendre encore plus
les possibilités de méta-programmaton, rendant l'exercice encore plus complexe
mais pas moins stimulant et intéressant.&lt;/p&gt;
&lt;p&gt;Également, nous avons pu, au sein de cet article, découvrir de nouvelles
fonctionnalités de C++11 comme le mot-clé &lt;code&gt;constexpr&lt;/code&gt;, les assertions statiques
avec &lt;code&gt;static_assert&lt;/code&gt; ou encore les &lt;em&gt;user defined literals&lt;/em&gt;. C++11 n'est donc
pas une révision mineure du langage mais a bel et bien redonné un coup de jeune
au langage. La liste des nouvelles fonctionnalités est encore bien plus longue
et vaut également le coup d'oeil.&lt;/p&gt;
&lt;p&gt;Au terme de cet article, j'espère donc ne pas avoir provoqué une overdose de
templates et j'espère vous avoir convaincu de leur réel pouvoir.&lt;/p&gt;
&lt;p&gt;Merci à Clément Janin pour la relecture et corrections.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Une liste plus exhaustive peut-être retrouvée sur
  &lt;a href="http://en.wikipedia.org/wiki/C%2B%2B11"&gt;wikipedia&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;il se trouve que cette fonction existe
  &lt;a href="http://en.cppreference.com/w/cpp/algorithm/max"&gt;déjà&lt;/a&gt; dans la bibliothèque
  standard&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;Les templates imposent très souvent des contraintes implicites sur les
  types comme par exemple le fait pour un type T d'être copiable (disposer
  d'un constructeur de copie)&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;size_t correspond à un type entier non signé&amp;#160;&lt;a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:5"&gt;
&lt;p&gt;&lt;code&gt;static_assert&lt;/code&gt; est une autre des nouveautés de C++11 et permet de poser des
  assertions durant la compilation. À la compilation, si l'évaluation de la
  condition est fausse, alors le compilateur reporte le message d'assertion.&amp;#160;&lt;a class="footnote-backref" href="#fnref:5" rev="footnote" title="Jump back to footnote 5 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:6"&gt;
&lt;p&gt;C'est ce qui s'appelle &lt;em&gt;template argument deduction&lt;/em&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:6" rev="footnote" title="Jump back to footnote 6 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Mathieu Stefani</dc:creator><pubDate>Sun, 19 May 2013 12:26:00 +0200</pubDate><guid>tag:www.lab-sl3.org,2013-05-19:articles/news/jouons-avec-c11-metaprogrammation-et-variadic-templates.html</guid><category>c++</category><category>c++11</category><category>templates</category><category>variadic templates</category><category>metaprogrammation</category></item><item><title>Utilisation du débogueur GDB</title><link>http://www.lab-sl3.org/articles/news/utilisation-du-debogueur-gdb.html</link><description>&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.gnu.org/software/gdb/"&gt;GDB&lt;/a&gt; est un logiciel permettant de débusquer les bogues pouvant apparaitre lors de l'exécution d'un programme. Ce débogueur peut s'exécuter sur la plupart des systèmes de type Unix.
Il est également compatible avec un grand nombre de langages tels que C, C++, Java. Il s'exécute aussi sur un ensemble d'architectures système (ARM, X86, X64, MIPS, Power-PC, SPARC, ect.) et est intégré au sein d'un grand nombre d'environnements de développement sous 
forme d'interface graphique (Code::Blocks, Xcode, Qt Creator ou encore Visual Studio). &lt;/p&gt;
&lt;p&gt;Nous allons nous intéresser dans cet article à son utilisation sous forme textuelle. Nous verrons d'abord comment démarrer une première session, ensuite nous verrons les points d'arrêt (breakpoint, watchdog), nous parlerons également de la modification des variables, des registres et de l'utilisation de la pile.&lt;/p&gt;
&lt;h2&gt;Première session&lt;/h2&gt;
&lt;p&gt;Pour notre premier lancement du débogueur GDB, nous allons lancer une session de celui-ci. Pour lancer une session, nous devons avoir un programme à déboguer. Nous allons utiliser le programme ci-dessous (ce code source provient de l'article &lt;a href="http://www.ibm.com/developerworks/library/l-gdb/"&gt;Linux software debugging with GDB&lt;/a&gt;) :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;wib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n01&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n02&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;diff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;diff&lt;/span&gt;    &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n01&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;n02&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n01&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;diff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;div&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;total&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;value&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;div&lt;/span&gt;     &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;total&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;div&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;total&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;div&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d wibed by %d equals %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;div&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;total&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ce programme est censé calculer une valeur cumulative grâce à la fonction wib() au sein d'une boucle et imprimer le résultat.&lt;/p&gt;
&lt;p&gt;Après avoir compilé ce code source avec l'argument ''-g'' pour permettre d'obtenir des informations de débogage utiles pour GDB, nous devons lancer le programme GDB.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;gcc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="n"&gt;wib&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;wib&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Nous avons deux façons de lancer GDB avec un programme :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;gdb&lt;/span&gt; &lt;span class="n"&gt;wib&lt;/span&gt;

&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;gdb&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="n"&gt;wib&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Après l'avoir lancé, nous pouvons démarrer la session de notre programme.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Notre session est lancée et nous recevons une erreur de type SIGFPE :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;Program&lt;/span&gt; &lt;span class="n"&gt;received&lt;/span&gt; &lt;span class="n"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;SIGFPE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Arithmetic&lt;/span&gt; &lt;span class="n"&gt;exception&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="mh"&gt;0x80483ea&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;wib&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;no1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;no2&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;wib&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;
&lt;span class="mi"&gt;7&lt;/span&gt;         &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;no1&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;diff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;En regardant les &lt;a href="https://en.wikipedia.org/wiki/Unix_signal"&gt;signaux&lt;/a&gt; de type &lt;a href="https://en.wikipedia.org/wiki/POSIX"&gt;POSIX&lt;/a&gt;, nous voyons que SIGFPE correspond à une erreur de calcul arithmetique exécuté par le programme. 
De plus, le message spécifie la ligne où s'est produite l'erreur ainsi que les variables concernées. 
Ainsi, nous voulons savoir les valeurs des variables présentes sur la ligne 9 :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;n01&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;diff&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Nous comprenons alors que l'erreur arithmétique est due à une bête division par zéro exécutée par notre programme.&lt;/p&gt;
&lt;p&gt;Maintenant, pour arrêter notre session GDB, nous pouvons appuyer sur les touches controle + d. &lt;/p&gt;
&lt;p&gt;Nous venons de déboguer notre programme de manière simple au sein d'une session GDB. Dans d'autres cas, nous pouvons avoir recours à des points d'arrêt pour faciliter la résolution de  plusieurs bogues au sein d'un même programme.&lt;/p&gt;
&lt;h2&gt;Les points d'arrêt&lt;/h2&gt;
&lt;p&gt;Le problème en exécutant directement le programme au sein de GDB est que le programme est lui même exécuté jusqu'à ce qu'il soit arrété. Ainsi, dans beaucoup de cas, ceci rend difficile la résolution d'un bogue offusqué, c'est pourquoi les points d'arrêt existent. Il y'a deux types de points d'arrêt: les breakpoints et les watchdogs. Nous allons voir ces deux types et dans quel but ils sont utiles.&lt;/p&gt;
&lt;h1&gt;Les breakpoints&lt;/h1&gt;
&lt;p&gt;Les breakpoints servent à stopper un programme à une instruction précise quand celui-ci est exécuté. Ceci a pour but de verifier l'état du programme à un instant T. La définition d'un breakpoint est très simple.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt; &lt;span class="n"&gt;wib&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;On utilise la commande ''break'' suivie du fichier source et de la ligne où mettre le breakpoint (dans un programme simple comme le notre, ayant un seul fichier source, nous pouvons également définir seulement la ligne).&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ainsi, en relançant la commande ''run'' au sein de GDB, notre programme a un point d'arrêt à l'instruction correspondant à la ligne 25 de notre code source.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;Breakpoint&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0xbffff954&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;eg1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;
&lt;span class="mi"&gt;25&lt;/span&gt;          &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;div&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;On peut donc mettre plusieurs breakpoints au sein de notre programme et décomposer l'exécution de celui-ci en étape. En utilisant la commande ''next'', on peut exécuter le programme en mode instruction par instruction (pas à pas). Ceci peut s'avérer particulièrement utile pour des programmes plus complexes que le notre. On peut alors vérifier de manière plus précise l'endroit dans notre code source qui est à l'origine d'un bogue qui peut s'avérer, à première vue, obscur. &lt;/p&gt;
&lt;p&gt;Nous pouvons alors continuer l'exécution du programme grâce à la commande ''continue'' ou ''step'' pour s'arrêter au prochain breakpoint.&lt;/p&gt;
&lt;p&gt;Il existe également un autre type de point d'arrêt, le conditional breakpoint. Ce type de breakpoint peut être plus utile dans des cas précis où nous avons besoin d'arrêter notre programme dans un cas conditionel. Nous pouvons avoir un conditional breakpoint de ce type :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;div&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Nous avons défini un conditional breakpoint à la place du breakpoint 1 défini précèdemment qui arrète le programme quand les variables div et value sont égales.
Il existe une autre manière de mettre en place un conditional breakpoint, voici un exemple :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;div&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pour finir sur les breakpoints, la commande ''info'' nous permet de lister l'ensemble des breakpoints mis au sein du programme exécuté.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;info&lt;/span&gt; &lt;span class="n"&gt;breakpoint&lt;/span&gt;
&lt;span class="n"&gt;Num&lt;/span&gt; &lt;span class="n"&gt;Type&lt;/span&gt;           &lt;span class="n"&gt;Disp&lt;/span&gt; &lt;span class="n"&gt;Enb&lt;/span&gt; &lt;span class="n"&gt;Address&lt;/span&gt;            &lt;span class="n"&gt;What&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="n"&gt;breakpoint&lt;/span&gt;     &lt;span class="n"&gt;keep&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;   &lt;span class="mh"&gt;0x0000000100000e7c&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;
        &lt;span class="n"&gt;stop&lt;/span&gt; &lt;span class="n"&gt;only&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;di&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Si vous voulez supprimer un breakpoint, il suffit d'utiliser la commande ''delete''.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;delete&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Les watchdogs&lt;/h1&gt;
&lt;p&gt;Les watchdogs sont un autre type de breakpoint. Ils sont utilisés pour arrêter le programme quand une variable spécifiée est changée ou lue. Il existe trois types de watchdogs :
&lt;em&gt; les ''watch'' qui arrètent le programme quand la variable spécifiée est changée ;
&lt;/em&gt; les ''rwatch'' qui arrètent le programme quand la variable spécifiée est lue ;
* les ''awatch'' qui arrètent le programme quand la variable spécifiée est lue et/ou changée.&lt;/p&gt;
&lt;p&gt;Ceci peuvent être donc très pratique pour la résolution de bogue, bien qu'ils engendrent une exécution plus lente du programme à déboguer.&lt;/p&gt;
&lt;p&gt;Voici un exemple d'utilisation d'un watchdog de type 'watch' :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;
&lt;span class="nl"&gt;Note:&lt;/span&gt; &lt;span class="n"&gt;breakpoint&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;also&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;pc&lt;/span&gt; &lt;span class="mh"&gt;0x100000e3f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;Breakpoint&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="mh"&gt;0x100000e3f&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mf"&gt;18.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Nous mettons d'abord un breakpoint sur la zone d'exécution à inspecter.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;watch&lt;/span&gt; &lt;span class="n"&gt;div&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;
&lt;span class="n"&gt;Hardware&lt;/span&gt; &lt;span class="n"&gt;watchpoint&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;div&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Nous mettons notre watchdog sur l'équivalence entre div et value.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;continue&lt;/span&gt;
&lt;span class="n"&gt;Continuing&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;Hardware&lt;/span&gt; &lt;span class="n"&gt;watchpoint&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;div&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;
&lt;span class="n"&gt;Old&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;New&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0xbffff954&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;eg1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;
&lt;span class="mi"&gt;25&lt;/span&gt;        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;en continuant l'exécution de notre programme, nous voyons que les valeurs ont changés. Ceci s'avère utile dans d'autres cas plus complexes.&lt;/p&gt;
&lt;h2&gt;Aller plus loin&lt;/h2&gt;
&lt;p&gt;Nous venons de voir l'utilisation basique de GDB pour déboguer un programme de manière simple. Nous allons maintenant aborder d'autres sujets tels que la manipulation des registres et de la pile.&lt;/p&gt;
&lt;h1&gt;Les registres&lt;/h1&gt;
&lt;p&gt;Les &lt;a href="https://fr.wikipedia.org/wiki/Registre_de_processeur"&gt;registres&lt;/a&gt; sont des emplacements de mémoire au sein du processeur de notre ordinateur. ce sont les zones mémoire les plus performantes pour l'accès direct; ainsi, ce sont les zones privilégiées pour la manipulation de données. Il existe différents types de registres, ceux dédiés au stockage de données (stockage de nombres entiers ou de nombres flottants), stockage d'adresse mémoire et d'autres types existent mais ils ne seront pas abordés ici.&lt;/p&gt;
&lt;p&gt;Grâce à GDB, nous pouvons visualiser les données et les adresses mémoires occupées par notre programme présentes au sein des registres.&lt;/p&gt;
&lt;p&gt;Pour visualiser l'ensemble des registres et leur contenu, nous pouvons utiliser cette commande :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;info&lt;/span&gt; &lt;span class="n"&gt;registers&lt;/span&gt;
&lt;span class="n"&gt;rax&lt;/span&gt;            &lt;span class="mh"&gt;0x8&lt;/span&gt;      &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="n"&gt;rbx&lt;/span&gt;            &lt;span class="mh"&gt;0x0&lt;/span&gt;      &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;rcx&lt;/span&gt;            &lt;span class="mh"&gt;0x0&lt;/span&gt;      &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;rdx&lt;/span&gt;            &lt;span class="mh"&gt;0x0&lt;/span&gt;      &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;rsi&lt;/span&gt;            &lt;span class="mh"&gt;0x8&lt;/span&gt;      &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="n"&gt;rdi&lt;/span&gt;            &lt;span class="mh"&gt;0x8&lt;/span&gt;      &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="n"&gt;rbp&lt;/span&gt;            &lt;span class="mh"&gt;0x7fff5fbff9f0&lt;/span&gt;   &lt;span class="mh"&gt;0x7fff5fbff9f0&lt;/span&gt;
&lt;span class="n"&gt;rsp&lt;/span&gt;            &lt;span class="mh"&gt;0x7fff5fbff9f0&lt;/span&gt;   &lt;span class="mh"&gt;0x7fff5fbff9f0&lt;/span&gt;
&lt;span class="n"&gt;r8&lt;/span&gt;             &lt;span class="mh"&gt;0x0&lt;/span&gt;      &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;r9&lt;/span&gt;             &lt;span class="mh"&gt;0x50&lt;/span&gt;     &lt;span class="mi"&gt;80&lt;/span&gt;
&lt;span class="n"&gt;r10&lt;/span&gt;            &lt;span class="mh"&gt;0x7fff5fbfeca0&lt;/span&gt;   &lt;span class="mi"&gt;140734799801504&lt;/span&gt;
&lt;span class="n"&gt;r11&lt;/span&gt;            &lt;span class="mh"&gt;0x246&lt;/span&gt;    &lt;span class="mi"&gt;582&lt;/span&gt;
&lt;span class="n"&gt;r12&lt;/span&gt;            &lt;span class="mh"&gt;0x0&lt;/span&gt;      &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;r13&lt;/span&gt;            &lt;span class="mh"&gt;0x0&lt;/span&gt;      &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;r14&lt;/span&gt;            &lt;span class="mh"&gt;0x0&lt;/span&gt;      &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;r15&lt;/span&gt;            &lt;span class="mh"&gt;0x0&lt;/span&gt;      &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;rip&lt;/span&gt;            &lt;span class="mh"&gt;0x100000e1c&lt;/span&gt;      &lt;span class="mh"&gt;0x100000e1c&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;wib&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;28&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;eflags&lt;/span&gt;         &lt;span class="mh"&gt;0x10246&lt;/span&gt;  &lt;span class="mi"&gt;66118&lt;/span&gt;
&lt;span class="n"&gt;cs&lt;/span&gt;             &lt;span class="mh"&gt;0x2b&lt;/span&gt;     &lt;span class="mi"&gt;43&lt;/span&gt;
&lt;span class="n"&gt;ss&lt;/span&gt;             &lt;span class="mh"&gt;0x0&lt;/span&gt;      &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;ds&lt;/span&gt;             &lt;span class="mh"&gt;0x0&lt;/span&gt;      &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;es&lt;/span&gt;             &lt;span class="mh"&gt;0x0&lt;/span&gt;      &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;fs&lt;/span&gt;             &lt;span class="mh"&gt;0x0&lt;/span&gt;      &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;gs&lt;/span&gt;             &lt;span class="mh"&gt;0x0&lt;/span&gt;      &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Nous pouvons donc voir les valeurs stockées au sein des différents registres, nous avons des entiers et des adresses mémoires. Ici les registres dédiés au stockage de nombres flottants ne sont pas affichés. Pour les afficher nous avons la commande suivante :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;info&lt;/span&gt; &lt;span class="n"&gt;all&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;registers&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;il est également possible d'afficher seulement le contenu d'un registre spécifique sous forme d'entier, hexadécimale ou flottante :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;eflags&lt;/span&gt; 
&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;66118&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;eflags&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x10246&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;eflags&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;13&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;9.26510519e-41&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pour finir sur les registres, il est également possible de modifier temporairement la valeur d'un registre.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;rbx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Comme vous pouvez le voir, la manipulation des registres au sein de GDB peut s'avérer utile pour détecter et résoudre des bogues tels que des fuites mémoire.&lt;/p&gt;
&lt;h1&gt;La pile&lt;/h1&gt;
&lt;p&gt;La &lt;a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)"&gt;pile&lt;/a&gt; est une structure de données basée sur le principe du "dernier entré, premier servi" (appelé également LIFO), on peut donner comme exemple une pile de livre. La pile est implémentée nativement dans la plupart des architectures de processeur, c'est un registre qui enregistre l'adresse du dernier élément stocké en mémoire. Dans un langage comme le C, les &lt;a href="https://fr.wikipedia.org/wiki/Algorithme_récursif"&gt;algorithmes récursifs&lt;/a&gt; utilisent une pile appelée la &lt;a href="https://en.wikipedia.org/wiki/Call_stack"&gt;pile d'exécution&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;GDB se sert d'une pile pour stocker les informations à propos des paramètres et variables locales de la dernière fonction appelée au sein de notre programme. Ainsi, quand notre programme s'interrompt, nous pouvons avoir accès à ses informations grâce à la pile.&lt;/p&gt;
&lt;p&gt;La pile de GDB est divisée en pièces appelées frames. Chaque frame est associée avec l'appel d'une fonction précise. Ainsi, à chaque appel de fonction au sein de notre programme exécuté, une frame est ajoutée au sein de la pile et un numéro lui est attribué par le débogueur. La sélection d'une frame se fait avec la commande du même nom :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="cp"&gt;#1  0x0000000100000e6c in main (argc=1, argv=0x7fff5fbffa60) at wib.c:23&lt;/span&gt;
&lt;span class="mi"&gt;23&lt;/span&gt;              &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;div&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="cp"&gt;#0  0x0000000100000e1c in wib (no1=8, no2=8) at wib.c:7&lt;/span&gt;
&lt;span class="mi"&gt;7&lt;/span&gt;           &lt;span class="n"&gt;result&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;no1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;diff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ceci nous permet donc de voir les étapes suivies pour les différents l'appels de fonction successifs avec l'état de chaque fonction grâce aux valeurs de leur paramètres et de leurs variables locales. Il est également possible de spécifier l'adresse mémoire de la frame plutôt que son numéro avec la commande ''frame''; pour sélectionner la frame suivante nous utilison la commande ''up'', et ''down'' pour la frame précèdente.&lt;/p&gt;
&lt;p&gt;Pour avoir plus d'informations sur la frame séléctionnée, nous utilisons la commande ''info'' :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;info&lt;/span&gt; &lt;span class="n"&gt;frame&lt;/span&gt;
&lt;span class="n"&gt;Stack&lt;/span&gt; &lt;span class="n"&gt;level&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="mh"&gt;0x7fff5fbffa50&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
 &lt;span class="n"&gt;rip&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x100000e6c&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;saved&lt;/span&gt; &lt;span class="n"&gt;rip&lt;/span&gt; &lt;span class="mh"&gt;0x7fff86b547e1&lt;/span&gt;
 &lt;span class="n"&gt;caller&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="mh"&gt;0x7fff5fbffa00&lt;/span&gt;
 &lt;span class="n"&gt;source&lt;/span&gt; &lt;span class="n"&gt;language&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
 &lt;span class="n"&gt;Arglist&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="mh"&gt;0x7fff5fbffa48&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0x7fff5fbffa60&lt;/span&gt;
 &lt;span class="n"&gt;Locals&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="mh"&gt;0x7fff5fbffa48&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Previous&lt;/span&gt; &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;sp&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="mh"&gt;0x7fff5fbffa50&lt;/span&gt;
 &lt;span class="n"&gt;Saved&lt;/span&gt; &lt;span class="n"&gt;registers&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="n"&gt;rsi&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="mh"&gt;0x7fff5fbffa30&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rdi&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="mh"&gt;0x7fff5fbffa3c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rbp&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="mh"&gt;0x7fff5fbffa40&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rip&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="mh"&gt;0x7fff5fbffa48&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Nous pouvons voir différentes informations telles que les adresses pour les paramètres de fonction, les variables locales, l'adresse de la prochaine frame, celle de la précèdente ou encore les registres utilisés. &lt;/p&gt;
&lt;p&gt;Il est également possible d'obtenir plus d'informations sur les arguments (paramètres de fonction), les variables locales ou encore les exceptions levées au sein de la frame séléctionnée grâce à ces différentes commandes :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;info&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt; 
&lt;span class="n"&gt;argc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;argv&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mh"&gt;0x7fff5fbffa60&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;info&lt;/span&gt; &lt;span class="n"&gt;locals&lt;/span&gt;
&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="n"&gt;div&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="n"&gt;total&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;info&lt;/span&gt; &lt;span class="n"&gt;catch&lt;/span&gt;
&lt;span class="n"&gt;Info&lt;/span&gt; &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;supported&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;compiler&lt;/span&gt; &lt;span class="n"&gt;combination&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pour finir sur la pile, pour décomposer l'appel successif des différentes fonctions au sein de notre programme, nous utilisons une commande qui s'avère très utile dans des codes sources de beaucoup plus grande envergure que le notre. C'est la commande ''backtrace'' qui permet de tracer les étapes qui suivent l'appel d'une frame à une autre :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;backtrace&lt;/span&gt;
&lt;span class="cp"&gt;#0  0x0000000100000e1c in wib (no1=8, no2=8) at wib.c:7&lt;/span&gt;
&lt;span class="cp"&gt;#1  0x0000000100000e6c in main (argc=1, argv=0x7fff5fbffa60) at wib.c:23&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Nous venons de voir l'utilisation du débogueur GDB de manière basique avec le lancement d'une session, la mise en place de points d'arrêt tel que les breakpoints ou les watchdogs, à une utilisation plus poussée telle que la manipulation des registres et de la pile au sein de l'environnement de GDB. D'autres éléments auraient pu être abordés tel que les tracepoints, la manipulation du code source avec le desassemblage du code machine exécuté, l'utilisation de GDB avec un autre langage que le C ou encore son utilisation à distance.&lt;/p&gt;
&lt;p&gt;Pour pouvoir aborder ses sujets, la &lt;a href="http://sourceware.org/gdb/current/onlinedocs/gdb/"&gt;documentation officielle&lt;/a&gt; est disponible. Il existe également une &lt;a href="http://darkdust.net/files/GDB%20Cheat%20Sheet.pdf"&gt;'cheatsheet'&lt;/a&gt; regroupant la plupart des commandes utiles de GDB.&lt;/p&gt;
&lt;p&gt;Il existe d'autres débogueurs qui ont été influencés par GDB, nous avons par exemple &lt;a href="http://lldb.llvm.org"&gt;LLDB&lt;/a&gt; qui est le débogueur de la suite &lt;a href="http://llvm.org"&gt;LLVM&lt;/a&gt; qui est particulièrement utile en débogage de programmes concurrents, ou encore &lt;a href="http://valgrind.org"&gt;Valgrind&lt;/a&gt; qui est spécialisé pour déboguer les fuites mémoire.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Simon ROUGER</dc:creator><pubDate>Thu, 09 May 2013 00:00:00 +0200</pubDate><guid>tag:www.lab-sl3.org,2013-05-09:articles/news/utilisation-du-debogueur-gdb.html</guid><category>gdb</category><category>gnu</category><category>débogueur</category><category>c</category></item><item><title>Traitement d'image : le Maze solver.</title><link>http://www.lab-sl3.org/articles/news/traitement-dimage-le-maze-solver.html</link><description>&lt;p&gt;&lt;a href="https://bitbucket.org/TrashZen/maze-solver/"&gt;Maze Solver&lt;/a&gt; est un simple solveur de labyrinthe. Il prend une image de labyrinthe (le type de labyrinthe disponible dans les magasines pour enfants) et trace la solution en rouge.
&lt;img alt="Maze solution example" src="https://bitbucket.org/TrashZen/maze-solver/raw/538669b9bc51399826acfa00a95d07b06d9f4edf/resource/doc/solution.png" /&gt;&lt;/p&gt;
&lt;h1&gt;Installation&lt;/h1&gt;
&lt;hr /&gt;
&lt;h2&gt;Outils requis&lt;/h2&gt;
&lt;p&gt;Pour compiler, vous avez besoin de CMake et de la librairie X11-dev&lt;/p&gt;
&lt;h4&gt;Linux&lt;/h4&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;libx11&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;cmake&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Mac OS&lt;/h4&gt;
&lt;p&gt;Téléchargez XQuartz (X11) &lt;a href="http://xquartz.macosforge.org/"&gt;ici&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Si vous n'avez pas homebrew, téléchargez le &lt;a href="http://brew.sh"&gt;ici&lt;/a&gt; (en bas de la page), puis&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;brew&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;cmake&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Compilation&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//bitbucket.org/TrashZen/maze-solver.git&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;maze&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;solver&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;cmake&lt;/span&gt; &lt;span class="n"&gt;CMakeLists&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;make&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;L'exécutable est créé dans le répertoire &lt;code&gt;build/&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;Utilisation&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;Lancez l'exécutable avec la commande suivante&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mazesolver&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Les images d'exemples sont dans le répertoire &lt;code&gt;resource/&lt;/code&gt;, donc lorsqu'il vous demande &lt;code&gt;Name of the maze to solve&lt;/code&gt; écrivez par exemple &lt;code&gt;resource/maze1.bmp&lt;/code&gt; (seul les images bmp sont autorisées, sauf si vous activez la gestion des JPEG et PNG (voir plus bas)). Une fois l'image affiché, cliquez sur le point de départ du labyrinthe, puis le point de fin.&lt;/p&gt;
&lt;p&gt;Attendez quelques secondes et la solution apparait.&lt;/p&gt;
&lt;h4&gt;JPEG et PNG&lt;/h4&gt;
&lt;p&gt;Si vous souhaitez ouvrir des images de labyrinthes au format JPEG ou PNG et que vous disposez de la libjpeg et libpng, alors il vous suffit de décommenter les lignes suivantes dans &lt;code&gt;CMakeLists.txt&lt;/code&gt; (fin du fichier)&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;# target_link_libraries(mazesolver X11 pthread png jpeg)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Dans &lt;code&gt;operator.h&lt;/code&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// #define cimg_use_png 1&lt;/span&gt;
&lt;span class="c1"&gt;// #define cimg_use_jpeg 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Algorithmes&lt;/h1&gt;
&lt;hr /&gt;
&lt;h3&gt;Préambule&lt;/h3&gt;
&lt;p&gt;Quelques informations sur les images en gÃ©nÃ©ral ...&lt;/p&gt;
&lt;p&gt;Une image noir et blanc est simplement un tableau de deux dimensions, chaque case correspond à un pixel.
La valeur d'une case correspond au niveau de gris : 0 correspond au noir, 255 au blanc.&lt;/p&gt;
&lt;p&gt;Pour une image couleur, chaque pixel est définit par trois valeurs : le rouge, le vert et le bleu. Chacun étant comprit entre 0 et 255.&lt;/p&gt;
&lt;p&gt;Afin d'ouvrir les images et de les modifier facilement, j'utilise une bibliothque nommée &lt;a href="http://cimg.sourceforge.net"&gt;CImg&lt;/a&gt; (cool image). Elle est simple à prendre en main et plutôt complète.&lt;/p&gt;
&lt;p&gt;Pour charger une image, il faut passer le chemin vers l'image au constructeur de la classe &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;CImg&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;lena_noir_et_blanc.bmp&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Exemple de parcourt de l'image noir et blanc utilisant :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;255&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Cet exemple calcul le négatif d'une image. Pour afficher le résultat, il suffit d'appeler la méthode &lt;code&gt;display&lt;/code&gt;.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;display&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Description de Maze Solver&lt;/h3&gt;
&lt;p&gt;Pour commencer je vais d'abord ouvrir une image de labyrinthe puis la copier dans une image temporaire pour pouvoir la modifier tout en gardant l'original.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;ImageUchar&lt;/span&gt; &lt;span class="nf"&gt;maze_image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;maze_name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_str&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="n"&gt;ImageUchar&lt;/span&gt; &lt;span class="nf"&gt;tmp_image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;maze_image&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;center&gt;&lt;img alt="Maze" src="https://bitbucket.org/TrashZen/maze-solver/raw/1e5e60f3239b4335cbf88695ae63424f4faee0ad/resource/maze3.bmp" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Le première étape est de transformer l'image couleur (rouge, vert, bleu) en noir et blanc (image en niveau de gris). Le gris est la moyenne pondérée de chaque couleurs. On va donc passer sur chaque pixel, faire la moyenne pondérée entre le rouge, le vert et le bleu et stocker le résultat dans l'image en niveau de gris.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;rgb_to_grayscale&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp_image&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;center&gt;&lt;img alt="Grayscale maze" src="https://bitbucket.org/TrashZen/maze-solver/raw/1e5e60f3239b4335cbf88695ae63424f4faee0ad/resource/doc/1_rgb_to_grayscale.png" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;L'Ã©tape suivante est la binarisation de l'image, c'est Ã  dire que l'image doit contenir uniquement du blanc ou du noir, mais pas de nuances de gris. Pour cela, j'utilise un seuil : tous les pixels infÃ©rieurs au seuil seront noir (0) et tous ceux supÃ©rieur seront blanc (255). Après cette étape, j'ai une image avec les murs du labyrinthe en noir et les chemins en blanc. Attention : la valeur du seuil est très importante car avec un seuil trop bas les murs peuvent disparaitre et avec un seuil trop haut les chemins peuvent disparaitre.&lt;/p&gt;
&lt;p&gt;Ici j'utilise un seuil de 210&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;binarization&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp_image&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;210&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;center&gt;&lt;img alt="Binary maze" src="https://bitbucket.org/TrashZen/maze-solver/raw/1e5e60f3239b4335cbf88695ae63424f4faee0ad/resource/doc/2_binarization.png" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Afin de corriger quelques imperfections possible de l'image et de la binarisation, j'effectue une érosion sur l'image. Cela a comme conséquence d'épaissir les régions noirs, soit les murs dans notre cas. &lt;/p&gt;
&lt;p&gt;Erosion : chaque pixel de l'image vaut le minimum de ses voisins et de lui-même. Voici un exemple d'érosion :&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="Erosion example" src="http://www.cs.auckland.ac.nz/courses/compsci773s1c/lectures/ImageProcessing-html/mor-pri-erosion.gif" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Application de l'érosion au labyrinthe :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;erosion&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp_image&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;center&gt;&lt;img alt="Erosion maze" src="https://bitbucket.org/TrashZen/maze-solver/raw/1e5e60f3239b4335cbf88695ae63424f4faee0ad/resource/doc/3_erosion.png" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Je dois désormais réduire la largeur des chemins pour qu'ils ne fassent qu'un pixel de large. J'utilise pour cela un algorithme de squelettisation qui permet de récupérer le squelette d'une image. Voici un exemple visuel qui est plus parlant qu'une longue explication :&lt;/p&gt;
&lt;p&gt;En gris claire est affiché l'image de base, et en noir son squelette.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="Skeleton example" src="http://www-artemis.it-sudparis.eu/Artemis/Research/Retinas/images/figure6.gif" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;L'algorithme consiste à appliquer une succession de diffèrents éléments structurants jusqu'à la stabilité de l'image. Voici le résultat sur notre labyrinthe :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;skeletonization&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp_image&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;center&gt;&lt;img alt="Skeleton maze" src="https://bitbucket.org/TrashZen/maze-solver/raw/1e5e60f3239b4335cbf88695ae63424f4faee0ad/resource/doc/5_skeletonization.png" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Dernière grosse étape : trouver le plus court chemin du point de début à l'arrivée. Pour cela j'utilise un algorithme très célèbre : le A* (astar). Voici un exemple :&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="A* example" src="http://upload.wikimedia.org/wikipedia/commons/f/f4/Pathfinding_A_Star.svg" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Le pixel vert est le point de départ, avec la valeur 0. Tous ses voisins sans valeur sont affectés avec la valeur du pixel courant + 1 et ajoutés dans une &lt;code&gt;queue&lt;/code&gt;. Puis on traite le premier pixel de la &lt;code&gt;queue&lt;/code&gt; et on recommence.&lt;/p&gt;
&lt;p&gt;Lorsque le point de fin est atteint (le point bleu sur l'exemple), l'algorithme est finit. Il suffit juste de suivre le chemin inverse, de la valeur maximal (19 sur l'exemple) vers 0.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;astar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp_image&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start_point&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end_point&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;center&gt;&lt;img alt="A* maze" src="https://bitbucket.org/TrashZen/maze-solver/raw/1e5e60f3239b4335cbf88695ae63424f4faee0ad/resource/doc/6_astar.png" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Dernière étape : superposer la solution avec l'image d'origine, en transformant le chemin blanc en chemin rouge. Et on effectue la sauvegarde de la solution.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;merge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp_image&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;maze_image&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;maze_image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;save_bmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;solution.bmp&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;center&gt;&lt;img alt="Solution maze" src="https://bitbucket.org/TrashZen/maze-solver/raw/1e5e60f3239b4335cbf88695ae63424f4faee0ad/resource/doc/7_solution.png" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Pour plus d'informations sur le traitement d'image : &lt;a href="http://raphaello.univ-fcomte.fr/ig/traitementimages/TraitementImages.htm"&gt;Le traitement d'images&lt;/a&gt;.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexis François</dc:creator><pubDate>Tue, 23 Apr 2013 00:00:00 +0200</pubDate><guid>tag:www.lab-sl3.org,2013-04-23:articles/news/traitement-dimage-le-maze-solver.html</guid><category>c++</category><category>traitement</category><category>image</category><category>cimg</category></item><item><title>Fonctionnement d'un Garbage Collector (Partie 2)</title><link>http://www.lab-sl3.org/articles/news/fonctionnement-dun-garbage-collector-partie-2.html</link><description>&lt;p&gt;Dans &lt;a href="http://www.lab-sl3.org/articles/news/fonctionnement-dun-garbage-collector.html"&gt;mon article précédent&lt;/a&gt;,
je vous ai introduit le rôle d'un &lt;em&gt;Garbage Collector&lt;/em&gt; : faciliter la gestion
de la mémoire.&lt;/p&gt;
&lt;p&gt;Il existe différentes méthodes, et celle que je vous ai présenté est la plus simple
et intuitive : le &lt;strong&gt;reference counting&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;Le reference counting&lt;/h2&gt;
&lt;p&gt;Le principe est simple, pour chaque portion de mémoire qu'on alloue, on a un
compteur qui indique le nombre de référence que l'on a sur la mémoire en question,
quand ce compteur atteint 0, plus personne n'utilise la mémoire et on peut donc
la libérer.&lt;/p&gt;
&lt;p&gt;Ce principe est utilisé par la &lt;strong&gt;GLib&lt;/strong&gt; avec &lt;em&gt;GObject&lt;/em&gt; (et donc, par &lt;strong&gt;GTK+&lt;/strong&gt;).&lt;/p&gt;
&lt;p&gt;Imaginons un cas particulier :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;j'alloue un objet &lt;code&gt;A&lt;/code&gt; ;&lt;/li&gt;
&lt;li&gt;à l'initialisation de &lt;code&gt;A&lt;/code&gt;, il alloue un objet &lt;code&gt;B&lt;/code&gt; ;&lt;/li&gt;
&lt;li&gt;à l'initialisation de &lt;code&gt;B&lt;/code&gt;, ce dernier référence l'objet &lt;code&gt;A&lt;/code&gt; ;&lt;/li&gt;
&lt;li&gt;je supprime la référence de &lt;code&gt;A&lt;/code&gt; que j'ai.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Voyons ce qu'il se passe dans ce cas :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;le compteur de référence de &lt;code&gt;A&lt;/code&gt; vaut 1 ;&lt;/li&gt;
&lt;li&gt;le compteur de référence de &lt;code&gt;A&lt;/code&gt; vaut 1, celui de &lt;code&gt;B&lt;/code&gt; vaut 1 ;&lt;/li&gt;
&lt;li&gt;le compteur de référence de &lt;code&gt;A&lt;/code&gt; vaut 2, celui de &lt;code&gt;B&lt;/code&gt; vaut 1 ;&lt;/li&gt;
&lt;li&gt;le compteur de référence de &lt;code&gt;A&lt;/code&gt; vaut 1, celui de &lt;code&gt;B&lt;/code&gt; vaut 1.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Après l'étape 4, le programme n'a plus aucun accès ni à &lt;code&gt;A&lt;/code&gt;, ni à &lt;code&gt;B&lt;/code&gt;, on dit
qu'ils sont &lt;strong&gt;unreachable&lt;/strong&gt; (inatteignable). Pourtant, leurs compteurs de référence
valent tout deux 1, ils ne sont donc pas libérés, à cause de la référence circulaire.&lt;/p&gt;
&lt;p&gt;Le &lt;em&gt;reference counting&lt;/em&gt; n'empêche donc pas les fuites de mémoire, il faut être
vigilant.&lt;/p&gt;
&lt;h2&gt;Les weak reference&lt;/h2&gt;
&lt;p&gt;Une &lt;strong&gt;weak reference&lt;/strong&gt; (référence faible) est une référence vers une zone mémoire
qui n'empêche pas cette mémoire d'être libérée par le &lt;em&gt;Garbage Collector&lt;/em&gt; :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;     &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gc_alloc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;  &lt;span class="cm"&gt;/* ptr est une &amp;#39;strong reference&amp;#39; */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ref&lt;/span&gt;     &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gc_ref&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;             &lt;span class="cm"&gt;/* ref est une &amp;#39;strong reference&amp;#39; */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;weakref&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                      &lt;span class="cm"&gt;/* weakref est une &amp;#39;weak reference&amp;#39; */&lt;/span&gt;

&lt;span class="n"&gt;gc_unref&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ref&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/* l&amp;#39;objet n&amp;#39;est pas libéré, on a toujours une strong reference&lt;/span&gt;
&lt;span class="cm"&gt; * vers ce dernier&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;

&lt;span class="n"&gt;gc_unref&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/* l&amp;#39;objet est libéré, il n&amp;#39;y a plus aucune strong reference vers&lt;/span&gt;
&lt;span class="cm"&gt; * ce dernier&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;

&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;weakref&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/* provoque un segmentation fault, car bien que weakref référence toujours&lt;/span&gt;
&lt;span class="cm"&gt; * l&amp;#39;objet en question, weakref n&amp;#39;est pas une strong reference, ce qui n&amp;#39;a&lt;/span&gt;
&lt;span class="cm"&gt; * pas empêché ce dernier d&amp;#39;être libéré.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Initialiser la mémoire, constructeur et destructeur&lt;/h2&gt;
&lt;p&gt;Les &lt;em&gt;weak reference&lt;/em&gt; peuvent donc être une solution pour l'algorithme de &lt;em&gt;reference
counting&lt;/em&gt;, en faisant en sorte que notre objet &lt;code&gt;B&lt;/code&gt; maintienne une &lt;em&gt;weak reference&lt;/em&gt;
sur notre objet &lt;code&gt;A&lt;/code&gt;, on évite ainsi la référence circulaire.&lt;/p&gt;
&lt;p&gt;Cependant, dans l'état, ce n'est pas suffisant car à la libération de &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;
n'est toujours pas libéré.&lt;/p&gt;
&lt;p&gt;L'idéal serait d'avoir un constructeur et un destructeur, qui permettent d'allouer
ou de désallouer la mémoire référencée par un objet (par objet j'entends zone mémoire).&lt;/p&gt;
&lt;p&gt;On pourrait imaginer ce genre de cas :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;mastruct&lt;/span&gt; &lt;span class="kt"&gt;mastruct_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;mastruct2&lt;/span&gt; &lt;span class="kt"&gt;mastruct2_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;mastruct&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;mastruct2_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;mastruct2&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;mastruct_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;mastruct_constructor&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;mastruct_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;mastruct_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gc_alloc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;mastruct2_t&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="cm"&gt;/* par defaut, pas de constructeur / destructeur */&lt;/span&gt;

    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* weak reference pour eviter les references circulaires */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;mastruct_destructor&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;mastruct_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;mastruct_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* on supprime la reference de B vers A */&lt;/span&gt;

    &lt;span class="n"&gt;gc_unref&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="cm"&gt;/* on supprime notre reference sur B */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;mastruct_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gc_alloc_full&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="k"&gt;sizeof&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;mastruct_t&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="n"&gt;mastruct_constructor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;mastruct_destructor&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* apres allocation, mastruct_constructor est appele,&lt;/span&gt;
&lt;span class="cm"&gt;     * elle alloue B et l initialise&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;

    &lt;span class="kt"&gt;mastruct2_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gc_ref&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* do stuff with a */&lt;/span&gt;

    &lt;span class="n"&gt;gc_unref&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* ici, plus de strong reference sur a, son compteur arrive a 0,&lt;/span&gt;
&lt;span class="cm"&gt;     * mastruct_destructor est appele, la memoire est liberee&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;

    &lt;span class="cm"&gt;/* do stuff with b */&lt;/span&gt;
    &lt;span class="cm"&gt;/* attention, b-&amp;gt;a vaut NULL ! */&lt;/span&gt;

    &lt;span class="n"&gt;gc_unref&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* plus de strong reference sur b, la memoire est liberee */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;L'inconvénient du &lt;em&gt;reference counting&lt;/em&gt; est donc que le développeur doit encore
s'assurer de la bonne gestion de la mémoire. Il doit encore beaucoup mettre la
main à la pâte, avec la différentiation des &lt;em&gt;strong references&lt;/em&gt; et des &lt;em&gt;weak
references&lt;/em&gt;, quand les utiliser, initialiser correctement la mémoire, etc...&lt;/p&gt;
&lt;p&gt;Au final, le &lt;em&gt;reference counting&lt;/em&gt; nous apporte juste la certitude de ne jamais
accéder à une mémoire non-allouée (et pour peu qu'on utilise pas de &lt;em&gt;weak references&lt;/em&gt;).
Ce n'est pas suffisant.&lt;/p&gt;
&lt;h2&gt;Le mark-and-sweep&lt;/h2&gt;
&lt;p&gt;Cet algorithme est bien plus performant car il n'implique pas le développeur dans
son déroulement.&lt;/p&gt;
&lt;p&gt;Ce type de &lt;em&gt;Garbage Collector&lt;/em&gt; définit deux types d'objets (zones mémoire) :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;les objets &lt;strong&gt;racines&lt;/strong&gt; : ceux que le développeur déclare, ils sont présent
dans les registres, les variables globales ou sur la pile (variables locales à une
fonction) ;&lt;/li&gt;
&lt;li&gt;les autres objets sont accessibles directement ou indirectement via les objets
racines.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;L'important dans cet algorithme est de connaître à tout moment quelles sont les
références détenues par un objet. Ce qui nous permet d'organiser notre liste
d'objets en arbre.&lt;/p&gt;
&lt;p&gt;Tous les objets inaccessibles directement ou indirectement via un objet &lt;em&gt;racine&lt;/em&gt;
sont considérés comme &lt;em&gt;unreachable&lt;/em&gt; et seront libérés lors de l'exécution de
l'algorithme.&lt;/p&gt;
&lt;p&gt;Cet algorithme n'est lancé que lorsqu'un objet est alloué :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;function gc_alloc (size)
    if available size &amp;lt; size
    then
        for each root object r
        do
            mark (r)
        end

        sweep ()
    end

    allocate object
    return allocated object
end

function mark (Object p)
    if not p.marked
    then
        p.marked = true

        for each object q referenced by p
        do
            mark (q)
        end
    end
end

function sweep ()
    for each object p
    do
        if p.marked
            p.marked = false
        else
            free (p)
        end
    end
end
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Comme le montre cet algorithme :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;on parcourt l'arbre des objets accessibles directement ou indirectement ;&lt;/li&gt;
&lt;li&gt;chacun de ces objets est marqué du passage de l'algorithme ;&lt;/li&gt;
&lt;li&gt;une fois le marquage fait, on passe à la phase de nettoyage ;&lt;/li&gt;
&lt;li&gt;chaque objet marqué, on supprime la marque ;&lt;/li&gt;
&lt;li&gt;chaque objet non-marqué est libéré.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Les objets non marqués sont les objets &lt;em&gt;unreachable&lt;/em&gt;, car le programme n'a plus
aucun moyen d'y accéder.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="schéma du mark-and-sweep" src="http://www.brpreiss.com/books/opus5/html/img1708.gif" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Dans le schéma ci-dessus :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;l'étape &lt;code&gt;a&lt;/code&gt; correspond à l'état de la mémoire avant le &lt;em&gt;mark-and-sweep&lt;/em&gt; ;&lt;/li&gt;
&lt;li&gt;l'étape &lt;code&gt;b&lt;/code&gt; correspond à l'état de la mémoire après le &lt;em&gt;mark&lt;/em&gt; ;&lt;/li&gt;
&lt;li&gt;l'étape &lt;code&gt;c&lt;/code&gt; correspond à l'état de la mémoire après le &lt;em&gt;sweep&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cet algorithme prend place directement dans le &lt;em&gt;HEAP&lt;/em&gt; du programme, il est donc
ardu de l'implémenter correctement de manière portable.&lt;/p&gt;
&lt;h2&gt;Boehm Garbage Collector&lt;/h2&gt;
&lt;p&gt;Fort heureusement, nous n'aurons pas à l'implémenter. À la place, nous apprendrons
à utiliser le &lt;strong&gt;Boehm-demers-Weiser garbage collector&lt;/strong&gt; (du nom des auteurs initiaux
du projet), ou plus simplement &lt;strong&gt;Boehm GC&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Son usage est extrêmement simple :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;inclure &lt;code&gt;gc.h&lt;/code&gt; ;&lt;/li&gt;
&lt;li&gt;appeler &lt;code&gt;GC_INIT()&lt;/code&gt; au début du programme (avant toute allocation) ;&lt;/li&gt;
&lt;li&gt;remplacer tous les appels de &lt;code&gt;malloc()&lt;/code&gt; et &lt;code&gt;calloc()&lt;/code&gt; par &lt;code&gt;GC_MALLOC()&lt;/code&gt; ;&lt;/li&gt;
&lt;li&gt;supprimer tous les appels de &lt;code&gt;free()&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Exemple provenant de &lt;a href="https://en.wikipedia.org/wiki/Boehm_garbage_collector"&gt;https://en.wikipedia.org/wiki/Boehm_garbage_collector&lt;/a&gt; :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;assert.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;gc.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;GC_INIT&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10000000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;GC_MALLOC&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;GC_MALLOC_ATOMIC&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

        &lt;span class="n"&gt;assert&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;GC_REALLOC&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;100000&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Heap size = %zu&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;GC_get_heap_size&lt;/span&gt; &lt;span class="p"&gt;());&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Le &lt;strong&gt;mark-and-sweep&lt;/strong&gt; à l'avantage d'éviter toute fuite de mémoire et offre un
recyclage de celle-ci très efficace, bien qu'il soit assez coûteux en ressources,
car il doit parcourir l'ensemble des objets pour chaque allocation.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">David Delassus</dc:creator><pubDate>Sat, 23 Mar 2013 12:00:00 +0100</pubDate><guid>tag:www.lab-sl3.org,2013-03-23:articles/news/fonctionnement-dun-garbage-collector-partie-2.html</guid></item><item><title>Gestion de la mémoire sur l'architecture x86</title><link>http://www.lab-sl3.org/articles/news/gestion-de-la-memoire-sur-larchitecture-x86.html</link><description>&lt;p&gt;Au travers de cet article, nous verrons comment le système d'exploitation gère la
mémoire sur les processeurs de type x86. Nous verrons donc comment fonctionne la
mémoire segmentée, la mémoire paginée, comment fonctionne l'allocation de mémoire
et nous ferons une petite introduction à la mémoire partagée.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;NB: Cet article contient des informations de l'article &lt;a href="http://wiki.osdev.org/Paging"&gt;Paging&lt;/a&gt;
sur &lt;a href="http://wiki.osdev.org"&gt;OSDev&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;h1&gt;Mémoire segmentée&lt;/h1&gt;
&lt;p&gt;Lorsque les systèmes d'exploitation fonctionnaient encore en 16-bits, la mémoire
était organisée en segment, chacun de ces segments étaient définis dans les registres
du micro-processeur :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CS&lt;/strong&gt; : l'emplacement du code ;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DS&lt;/strong&gt; : l'emplacement des données ;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SS&lt;/strong&gt; : l'emplacement de la pile ;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ES&lt;/strong&gt;, &lt;strong&gt;FS&lt;/strong&gt;, &lt;strong&gt;GS&lt;/strong&gt; : des segments supplémentaires.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Chaque programme a ainsi accès à la totalité de la mémoire physique. Ce système
est peu pratique, car si un programme vient à corrompre la mémoire, c'est tout
le système qui est compromis.&lt;/p&gt;
&lt;h1&gt;Mémoire paginée&lt;/h1&gt;
&lt;p&gt;C'est dans ce contexte, avec l'arrivée du 32-bits, qu'est apparu le concept de
mémoire paginée. Le fonctionnement est simple : la mémoire n'est plus divisée en
segment, mais en page.&lt;/p&gt;
&lt;p&gt;On définit donc le principe de mémoire virtuelle. Pour faire simple, chaque tâche
&lt;strong&gt;croit&lt;/strong&gt; pouvoir accéder à la totalité de la mémoire &lt;strong&gt;physique&lt;/strong&gt;, chaque adresse
virtuelle est &lt;em&gt;mappée&lt;/em&gt; sur une adresse &lt;em&gt;physique&lt;/em&gt;. Ainsi si le programme A veut
accéder à l'adresse 0x1000, il accédera en réalité à l'adresse physique 0x2000,
et si un programme B veut accéder à l'adresse 0x1000, il accédera en réalité à
l'adresse physique 0x3000.&lt;/p&gt;
&lt;p&gt;Ainsi, le processeur a connaissance de ce &lt;em&gt;mappage&lt;/em&gt; au travers de tables qui associent
une adresse virtuelle à une adresse physique.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="schéma de mémoire paginée" src="http://wiki.osdev.org/images/a/a7/Virtual_memory.png" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Le processeur est capable de traduire une adresse virtuelle en adresse physique
grâce au &lt;strong&gt;MMU&lt;/strong&gt; (&lt;strong&gt;M&lt;/strong&gt;emory &lt;strong&gt;M&lt;/strong&gt;anagment &lt;strong&gt;U&lt;/strong&gt;nit).&lt;/p&gt;
&lt;h2&gt;Mettre en place la mémoire paginée&lt;/h2&gt;
&lt;p&gt;Pour faire la traduction adresse virtuelle &amp;lt;-&amp;gt; adresse physique, le &lt;em&gt;MMU&lt;/em&gt; a besoin
de certaines structures :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;un répertoire de page (&lt;em&gt;Page Directory&lt;/em&gt;) : il s'agit d'un tableau contenant
l'adresse physique de tables de pages, il peut contenir 1024 entrées de chacune
4 octets et son adresse physique est stockée dans le registre &lt;strong&gt;CR3&lt;/strong&gt; afin que le
&lt;em&gt;MMU&lt;/em&gt; puisse faire la traduction.&lt;/li&gt;
&lt;li&gt;des tables de pages (&lt;em&gt;Page Table&lt;/em&gt;) : ce sont des tableaux de 1024 entrées (de
4 octets), où chaque entrée contient l'adresse physique d'une page.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Structure d'une entrée du répertoire de page&lt;/h3&gt;
&lt;p&gt;Une entrée a une taille de 4 octets (32 bits) :&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="entrée du répertoire de page" src="http://wiki.osdev.org/images/9/94/Page_dir.png" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S : définit la taille d'une page (0 pour 4ko, 1 pour 4Mo) ;&lt;/li&gt;
&lt;li&gt;A : définit s'il y a eu un accès en lecture/écriture à la page ;&lt;/li&gt;
&lt;li&gt;D : définit si la page peut-être mise en cache ;&lt;/li&gt;
&lt;li&gt;W : définit le mode de mise en cache (&lt;em&gt;Write-Through&lt;/em&gt; si 1, &lt;em&gt;Write-Back&lt;/em&gt; sinon) ;&lt;/li&gt;
&lt;li&gt;U : définit si la page peut-être accédée par tout le monde ou non ;&lt;/li&gt;
&lt;li&gt;R : définit si la page peut-être accédée en écriture ;&lt;/li&gt;
&lt;li&gt;P : définit si la page est présente dans la mémoire physique, si la page a été
placée dans la &lt;em&gt;swap&lt;/em&gt; (sur le disque dur), alors elle n'est pas présente et un
accès à cette page provoquera un &lt;em&gt;Page Fault&lt;/em&gt; que le système doit gérer (récupérer
la page de la &lt;em&gt;swap&lt;/em&gt; pour la remettre en RAM).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Structure d'une entrée de la table de page&lt;/h3&gt;
&lt;p&gt;De même que pour le répertoire de page, une entrée a une taille de 4 octets :&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="entrée d'une table de page" src="http://wiki.osdev.org/images/9/9b/Page_table.png" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;G : s'il est défini, cela empêche le &lt;strong&gt;TLB&lt;/strong&gt; (&lt;strong&gt;T&lt;/strong&gt;ranslation &lt;strong&gt;L&lt;/strong&gt;ookaside &lt;strong&gt;B&lt;/strong&gt;uffer
de mettre à jour l'adresse dans son cache si le registre &lt;strong&gt;CR3&lt;/strong&gt; est redéfini,
le registre &lt;strong&gt;CR4&lt;/strong&gt; doit être défini correctement pour activer cette fonctionnalité) ;&lt;/li&gt;
&lt;li&gt;D : défini s'il y a eu un accès en écriture à la page ;&lt;/li&gt;
&lt;li&gt;C : équivalent du bit D du répertoire de page ;&lt;/li&gt;
&lt;li&gt;le reste est équivalent au répertoire de page.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Récapitulatif&lt;/h3&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="schéma de la structure de la pagination sur le x86" src="http://ompldr.org/vaHBhOQ/Paging_Structure.gif" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Le cadre rouge représente une adresse virtuelle.&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;INVLPG&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;INVLPG&lt;/code&gt; est une instruction, disponible depuis le &lt;em&gt;i468&lt;/em&gt;, elle permet d'invalider
une entrée dans le &lt;em&gt;TLB&lt;/em&gt;.&lt;/p&gt;
&lt;h3&gt;Détails sur le TLB&lt;/h3&gt;
&lt;p&gt;Le &lt;em&gt;TLB&lt;/em&gt; est un cache de traduction de page mémoire, lorsque le processeur veut
traduire une adresse virtuelle en adresse physique, le &lt;em&gt;TLB&lt;/em&gt; est consulté. Si
l'adresse est présente dans le &lt;em&gt;TLB&lt;/em&gt;, aucune traduction n'est faite, sinon le
&lt;em&gt;MMU&lt;/em&gt; réalise la traduction et place le résultat dans le &lt;em&gt;TLB&lt;/em&gt;.&lt;/p&gt;
&lt;h3&gt;Fonctionnement de la traduction adresse virtuelle &amp;lt;-&amp;gt; adresse physique&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Les informations de cette section sont tirées de l'article &lt;a href="http://a.michelizza.free.fr/pmwiki.php?n=TutoOS.Mm"&gt;suivant&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;NB: Une adresse virtuelle est également appelée adresse linéaire&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;le processeur utilise le registre &lt;strong&gt;CR3&lt;/strong&gt; pour connaître l'adresse physique du
répertoire de pages ;&lt;/li&gt;
&lt;li&gt;les 10 premiers bits de l'adresse virtuelle forment un offset (entre 0 et 1023),
qui identifie une entrée du répertoire de page ;&lt;/li&gt;
&lt;li&gt;cette entrée contient l'adresse physique d'une table de pages ;&lt;/li&gt;
&lt;li&gt;les 10 bits suivants de l'adresse virtuelle forment un offset (toujours entre
0 et 1023) qui identifie une entrée dans la table de pages ;&lt;/li&gt;
&lt;li&gt;l'entrée de la table de page identifie une page de 4ko dans la mémoire physique ;&lt;/li&gt;
&lt;li&gt;les 12 derniers bits de l'adresse virtuelle forment un offset (compris en 0 et
4095) qui permet d'identifier l'adresse physique.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="schéma de la traduction d'adresse" src="http://a.michelizza.free.fr/uploads/TutoOS/paging_memory.png" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;h3&gt;Activer la pagination&lt;/h3&gt;
&lt;p&gt;Pour activer la pagination, il suffit de placer l'adresse physique du répertoire
de page dans le registre &lt;strong&gt;CR3&lt;/strong&gt; et d'activer le bit de pagination du registre
&lt;strong&gt;CR0&lt;/strong&gt; :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;page_directory&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;cr3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;eax&lt;/span&gt;

&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cr0&lt;/span&gt;
&lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x80000000&lt;/span&gt;
&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;cr0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;eax&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Espaces d'adressages&lt;/h2&gt;
&lt;p&gt;Comme vu ci-dessus, on a donc deux types d'adresses :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;les adresses virtuelles (ou linéaires) ;&lt;/li&gt;
&lt;li&gt;les adresses physiques.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Une fois la pagination mise en place, toutes les adresses (pour les pointeurs, etc...)
sont des adresses virtuelles (il est donc important de &lt;em&gt;mapper&lt;/em&gt; l'espace d'adressage
du système d'exploitation avant d'activer la pagination).&lt;/p&gt;
&lt;p&gt;Avec ce principe d'adresse virtuelle, chaque processus croit qu'il peut accéder
à la totalité de la mémoire, et même plus.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q : Mais comment un processus peut accéder à plus de mémoire que disponible ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;R : Si on mappe dans l'espace d'adressage virtuelle des adresses présentes sur
un autre périphérique de stockage (disons le disque dur par exemple), on a ainsi
accès à plus de mémoire.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q: C'est comme ça que fonctionne la &lt;em&gt;swap&lt;/em&gt; ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;R : Non, lorsqu'il n'y a plus de page disponible pour l'allocation, le système
d'exploitation va placer certaines pages dont le A (rappel: s'il y a eu un accès
en lecture/écriture sur la page) est à 0, sur le disque dur, et lorsqu'un accès
à ces pages sera demandé (le bit P, présent en mémoire, vaut 0), alors le système
les replacera en RAM.&lt;/p&gt;
&lt;h2&gt;Changement de contexte et parallélisme&lt;/h2&gt;
&lt;p&gt;Les systèmes d'aujourd'hui sont multitâches. Et dans un système qui utilise la
pagination, chaque processus possède son propre espace d'adressage virtuel. Cela
implique que chaque processus à son propre répertoire de pages. Quand l'ordonnanceur
du système va passer d'un processus à l'autre, on changera la valeur du registre
&lt;strong&gt;CR3&lt;/strong&gt; afin qu'il pointe vers le bon répertoire de pages (celui du processus que
l'on veut exécuter), on appelle cela le &lt;strong&gt;changement de contexte&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Concernant le parallélisme, nous avions parlé dans l'article concernant &lt;a href="http://www.lab-sl3.org/articles/news/le-parallelisme-avec-fork.html"&gt;fork&lt;/a&gt;
de ce qu'il se passait réellement lors d'un &lt;code&gt;fork&lt;/code&gt;. On peut maintenant décrire
en détail ce qu'il va se passer (je ne présenterai pas le principe de &lt;strong&gt;copy-on-write&lt;/strong&gt;) :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;clonage du répertoire de pages dans le nouveau processus :&lt;ol&gt;
&lt;li&gt;création d'un nouveau répertoire de pages ;&lt;/li&gt;
&lt;li&gt;clonage des tables de pages dans le nouveau répertoire :&lt;ol&gt;
&lt;li&gt;désactivation de la pagination ;&lt;/li&gt;
&lt;li&gt;copie de la mémoire physique du premier processus vers le nouveau ;&lt;/li&gt;
&lt;li&gt;réactivation de la pagination.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;création du nouveau processus ;&lt;/li&gt;
&lt;li&gt;attachement du nouveau répertoire de pages à ce processus ;&lt;/li&gt;
&lt;li&gt;ajout du processus à la liste des processus de l'ordonnanceur.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Pour la mise en place du &lt;strong&gt;copy-on-write&lt;/strong&gt;, l'algorithme est plus complexe, là on
copie simplement la totalité de la mémoire utilisée par le processus.&lt;/p&gt;
&lt;h2&gt;Au sein de l'espace d'adressage virtuel&lt;/h2&gt;
&lt;p&gt;Chaque processus organise son espace d'adressage de manière segmentée, ainsi lors
du &lt;em&gt;changement de contexte&lt;/em&gt;, la valeur des registres du micro-processeur est mise
à jour, c'est le rôle du système d'exploitation de garder une trace de ces valeurs
afin de réaliser cette mise à jour.&lt;/p&gt;
&lt;h1&gt;Allocation de mémoire&lt;/h1&gt;
&lt;p&gt;Maintenant que l'on sait exactement comment fonctionne la gestion de la mémoire,
nous allons nous attaquer à ce qui nous intéresse : comment fonctionne l'allocation ?&lt;/p&gt;
&lt;p&gt;On a déjà parlé dans un &lt;a href="http://www.lab-sl3.org/articles/news/fonctionnement-et-implementation-dun-gestionnaire-dallocation-en-c.html"&gt;article précédent&lt;/a&gt;
du fonctionnement de l'allocation dynamique au sein d'un programme. On avait
utilisé l'appel système &lt;code&gt;sbrk&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Fonctionnement des appels systèmes brk et sbrk&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;NB: Les schémas présents dans cette section sont tirés du PDF &lt;a href="http://www.inf.udec.cl/~leo/Malloc_tutorial.pdf"&gt;Malloc Tutorial&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Chaque processus possède un tas, avec trois bornes :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;son début ;&lt;/li&gt;
&lt;li&gt;sa taille maximum ;&lt;/li&gt;
&lt;li&gt;le &lt;strong&gt;break&lt;/strong&gt;, qui délimite l'espace alloué et l'espace non-alloué.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="schéma du tas" src="http://ompldr.org/vaG95Nw/heap-schema.png" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Tenter d'accéder à une adresse au delà du &lt;em&gt;break&lt;/em&gt; provoquera une erreur de &lt;em&gt;bus&lt;/em&gt;.
Les appels systèmes &lt;code&gt;brk&lt;/code&gt; et &lt;code&gt;sbrk&lt;/code&gt; permettent de modifier ce &lt;em&gt;break&lt;/em&gt; :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int brk (void *addr)&lt;/code&gt; : défini l'adresse du &lt;em&gt;break&lt;/em&gt;, il retourne &lt;code&gt;0&lt;/code&gt; en
cas de succès, et &lt;code&gt;-1&lt;/code&gt; en cas d'erreur (et &lt;code&gt;errno&lt;/code&gt; est défini à &lt;code&gt;ENOMEM&lt;/code&gt;) ;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void *sbrk (intptr_t increment)&lt;/code&gt; : incrémente l'adresse du &lt;em&gt;break&lt;/em&gt;, il retourne
la précédente adresse du &lt;em&gt;break&lt;/em&gt; en cas de succès, ou &lt;code&gt;(void *) -1&lt;/code&gt; en cas d'erreur
(et &lt;code&gt;errno&lt;/code&gt; vaut &lt;code&gt;ENOMEM&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Comme vous le savez, la mémoire est organisée en page, le tas n'y échappe pas :&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="schéma du tas paginé" src="http://ompldr.org/vaG95YQ/heap-schema2.png" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;On peut voir sur ce schéma que le &lt;em&gt;break&lt;/em&gt; est en plein milieu d'une page, cette
zone mémoire entre le &lt;em&gt;break&lt;/em&gt; et la fin de la page est appelée &lt;em&gt;no-man's land&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Cette mémoire est accessible et un accès au delà de la limite du &lt;em&gt;break&lt;/em&gt; peut
fonctionner pour de petite portion de mémoire, mais provoquera une erreur si l'on
dépasse la limite de la page. Il peut donc s'avérer dangereux d'écrire dans cette
zone, bien qu'accessible.&lt;/p&gt;
&lt;p&gt;Lorsque &lt;code&gt;brk&lt;/code&gt; et &lt;code&gt;sbrk&lt;/code&gt; vont redéfinir le &lt;em&gt;break&lt;/em&gt;, le système déterminera si
oui ou non il faut allouer une nouvelle page mémoire.&lt;/p&gt;
&lt;h2&gt;Fonctionnement de l'appel système mmap&lt;/h2&gt;
&lt;p&gt;Un appel de &lt;code&gt;mmap&lt;/code&gt; demande au noyau de &lt;em&gt;mapper&lt;/em&gt; un certain nombre d'octet d'un
objet représenté par un descripteur de fichier à une certaine adresse si on le
spécifie :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;sys/mman.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;mmap&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;prot&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;off_t&lt;/span&gt; &lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;addr&lt;/code&gt; : spécifie l'adresse où l'on souhaite que le fichier soit &lt;em&gt;mappé&lt;/em&gt; (ou
&lt;code&gt;NULL&lt;/code&gt; pour laisser le noyau décider) ;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;len&lt;/code&gt; : taille des données à &lt;em&gt;mapper&lt;/em&gt; ;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prot&lt;/code&gt; : défini les paramètres d'accès aux pages nouvellement &lt;em&gt;mappée&lt;/em&gt; :&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PROT_NONE&lt;/code&gt; : on ne peut pas accéder aux pages (inutile) ;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PROT_READ&lt;/code&gt; : les pages peuvent être accédées en lecture ;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PROT_WRITE&lt;/code&gt; : les pages peuvent être accédées en écriture ;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PROT_EXEC&lt;/code&gt; : les pages peuvent être exécutée.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flags&lt;/code&gt; : défini le type du &lt;em&gt;mapping&lt;/em&gt; :&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MAP_FIXED&lt;/code&gt; : Oblige &lt;code&gt;mmap&lt;/code&gt; à placer le &lt;em&gt;mappage&lt;/em&gt; à l'adresse exacte demandée
(&lt;code&gt;addr&lt;/code&gt; doit être un multiple de la taille d'une page), si la région spécifiée par
&lt;code&gt;addr&lt;/code&gt; et &lt;code&gt;len&lt;/code&gt; déborde sur des pages déjà &lt;em&gt;mappées&lt;/em&gt;, alors ces pages sont &lt;em&gt;démappées&lt;/em&gt;
pour laisser la place aux nouvelles, son usage est déconseillé ;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MAP_PRIVATE&lt;/code&gt; : les pages nouvellement &lt;em&gt;mappées&lt;/em&gt; ne sont pas partagées entre
les processus, s'il y a un &lt;code&gt;fork&lt;/code&gt;, alors le principe du &lt;strong&gt;copy-on-write&lt;/strong&gt; s'applique
et les modifications faites ne sont pas reflétées dans le &lt;em&gt;mapping&lt;/em&gt; des autres processus ;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MAP_SHARED&lt;/code&gt; : les pages nouvellement &lt;em&gt;mappées&lt;/em&gt; sont partagées avec tous les
autres processus qui &lt;em&gt;mappent&lt;/em&gt; le même fichier, écrire dans ce &lt;em&gt;mapping&lt;/em&gt; équivaut
à écrire dans le fichier, et lire dedans reflétera les écritures des autres processus ;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MAP_ANONYMOUS&lt;/code&gt; : le &lt;em&gt;mappage&lt;/em&gt; n'est pas associé à un fichier (il s'agit
donc d'une allocation de mémoire), ainsi &lt;code&gt;fd&lt;/code&gt; doit être à &lt;code&gt;-1&lt;/code&gt; ;&lt;/li&gt;
&lt;li&gt;pour les autres options, je vous laisse voir le manuel.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fd&lt;/code&gt; : le descripteur de fichier à &lt;em&gt;mapper&lt;/em&gt; ;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;offset&lt;/code&gt; : offset au sein du fichier à partir duquel on va &lt;em&gt;mapper&lt;/em&gt; dans l'espace
d'adressage virtuel.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;mmap&lt;/code&gt; retourne le pointeur vers la mémoire nouvellement &lt;em&gt;mappée&lt;/em&gt; en cas de succès,
ou &lt;code&gt;MAP_FAILED&lt;/code&gt; (soit &lt;code&gt;(void *) -1&lt;/code&gt;) en cas d'erreur (et &lt;code&gt;errno&lt;/code&gt; est défini).&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="schéma de mmap" src="http://images.devshed.com/ds/stories/Advanced_File_IO/image_1.JPG" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;h3&gt;Lire un fichier avec mmap&lt;/h3&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;

&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;fcntl.h&amp;gt;&lt;/span&gt;

&lt;span class="cp"&gt;#include &amp;lt;sys/stat.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;sys/types.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;sys/mman.h&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;file_t&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;file_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;read_file&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;file_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;file_t&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="cm"&gt;/* don&amp;#39;t check for simplicity */&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;stat&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;open&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;O_RDONLY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;fprintf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Can&amp;#39;t read %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;free&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fstat&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;fprintf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Can&amp;#39;t get file size&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;close&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;free&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;st_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* we map the whole file, privately */&lt;/span&gt;
    &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mmap&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PROT_READ&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MAP_FILE&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;MAP_PRIVATE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MAP_FAILED&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;fprintf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Can&amp;#39;t map file&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;close&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;free&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;close_file&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;file_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* unmap memory */&lt;/span&gt;
    &lt;span class="n"&gt;munmap&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;close&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;free&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Autres cas d'utilisations&lt;/h3&gt;
&lt;p&gt;Dans certaines implémentations, &lt;code&gt;malloc()&lt;/code&gt; utilise &lt;code&gt;mmap&lt;/code&gt; pour allouer de la
mémoire (notamment quand la taille demandée dépasse la taille d'une page).&lt;/p&gt;
&lt;p&gt;On peut également mettre en place un système de mémoire partagée (anonyme ou nommée)
avec, nous verrons cela après.&lt;/p&gt;
&lt;h1&gt;Fonctionnement de la mémoire partagée&lt;/h1&gt;
&lt;p&gt;Dans certains cas, deux processus ont besoin d'échanger des données, la mémoire
partagée permet cela.&lt;/p&gt;
&lt;p&gt;Le principe est simple, dans l'espace d'adressage virtuel des deux programmes,
chacun aura une ou plusieurs pages qui &lt;em&gt;mappent&lt;/em&gt; le &lt;strong&gt;même&lt;/strong&gt; espace physique (ou
&lt;strong&gt;frame&lt;/strong&gt;). Ainsi, ils peuvent lire et écrire dans cette mémoire pour échanger
des données.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="schéma de la mémoire partagée" src="http://ompldr.org/vaHAwZQ/sharedmem.png" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;h2&gt;Une mémoire partagée avec mmap&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;

&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;fcntl.h&amp;gt;&lt;/span&gt;

&lt;span class="cp"&gt;#include &amp;lt;sys/mman.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sharedmem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;child_pid&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* allocation of shared memory */&lt;/span&gt;
    &lt;span class="n"&gt;sharedmem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mmap&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4096&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PROT_READ&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;PROT_WRITE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MAP_ANONYMOUS&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;MAP_SHARED&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sharedmem&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MAP_FAILED&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;fprintf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Can&amp;#39;t allocate shared memory&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;exit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;strcpy&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sharedmem&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;string 1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Parent: %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sharedmem&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* now fork ! */&lt;/span&gt;
    &lt;span class="n"&gt;child_pid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fork&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;child_pid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;:
            &lt;span class="n"&gt;fprintf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Can&amp;#39;t fork&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;munmap&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sharedmem&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4096&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;exit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="cm"&gt;/* child process */&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;:
            &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Child: %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sharedmem&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

            &lt;span class="n"&gt;sleep&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

            &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Child: %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sharedmem&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

            &lt;span class="n"&gt;munmap&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sharedmem&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4096&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;exit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EXIT_SUCCESS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="cm"&gt;/* parent process */&lt;/span&gt;
        &lt;span class="nl"&gt;default:&lt;/span&gt;
            &lt;span class="n"&gt;sleep&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

            &lt;span class="n"&gt;strcpy&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sharedmem&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;string 2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

            &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Parent: %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sharedmem&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

            &lt;span class="cm"&gt;/* wait for the child to finish */&lt;/span&gt;
            &lt;span class="n"&gt;sleep&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

            &lt;span class="n"&gt;munmap&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sharedmem&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4096&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;exit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EXIT_SUCCESS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Dans ce programme :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;on alloue un espace mémoire partagé ;&lt;/li&gt;
&lt;li&gt;on y écrit une chaîne de caractère que l'on affiche dans le parent ;&lt;/li&gt;
&lt;li&gt;dans l'enfant on affiche le contenu de la mémoire partagée ;&lt;/li&gt;
&lt;li&gt;on attend 3 secondes dans l'enfant, puis on affiche à nouveau la mémoire partagé, et on quitte ;&lt;/li&gt;
&lt;li&gt;pendant ce temps la, dans le parent, on attend 2 secondes, puis on redéfinit le
contenu de la mémoire partagée, et on l'affiche, on attend encore 2 secondes et on quitte.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Voici le résultat :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="go"&gt;Parent: string 1&lt;/span&gt;
&lt;span class="go"&gt;Child: string 1&lt;/span&gt;
&lt;span class="go"&gt;Parent: string 2&lt;/span&gt;
&lt;span class="go"&gt;Child: string 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Comme on peut le voir, l'échange de données a eu lieu.&lt;/p&gt;
&lt;p&gt;Cependant, il faut faire attention à ne pas lire en même temps qu'un autre processus
écrit, mettre en place un système de &lt;em&gt;lock&lt;/em&gt; permettrait d'éviter ce genre de
désagrément et on en arrive à faire de la &lt;strong&gt;concurrence&lt;/strong&gt;.&lt;/p&gt;
&lt;h3&gt;Mémoire partagée avec les Unices&lt;/h3&gt;
&lt;p&gt;Les systèmes de type UNIX fournissent une API permettant de mettre en place une mémoire partagée entre
deux processus distinct :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;shmget&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;key_t&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;shmflg&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;key&lt;/code&gt; : Clé identifiant le segment de mémoire partagée ;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size&lt;/code&gt; : Taille du segment de mémoire partagée ;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shmflg&lt;/code&gt; : Permissions d'accès au segment de mémoire partagée et ces quelques flags :&lt;ul&gt;
&lt;li&gt;&lt;code&gt;IPC_CREAT&lt;/code&gt; : Créé le nouveau segment ;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IPC_EXCL&lt;/code&gt; : Utilisé avec &lt;code&gt;IPC_CREAT&lt;/code&gt; pour prévenir des erreurs si le segment existe déjà ;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SHM_HUGETLB&lt;/code&gt; : Alloue le segment dans les &lt;em&gt;grandes pages&lt;/em&gt; (de plus de 4ko de taille) ;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SHM_NORESERVE&lt;/code&gt; : N'alloue pas d'espace dans la &lt;em&gt;swap&lt;/em&gt; pour cette page,
ainsi si la page est en &lt;em&gt;swap&lt;/em&gt;, un accès à celle-ci provoquera une erreur de segmentation
au lieu d'un &lt;em&gt;Page Fault&lt;/em&gt; (qui permet en temps normal de replacer la page dans la
mémoire physique).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Elle retourne ensuite l'identifiant du segment de mémoire partagée.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pour changer les permissions et autres caractéristiques du segment de mémoire partagée :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;shmctl&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;shmid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;shmid_ds&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;shmid&lt;/code&gt; : Identifiant du segment de mémoire partagée ;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cmd&lt;/code&gt; : Commande à exécuter sur le segment de mémoire partagée :&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SHM_LOCK&lt;/code&gt; : Pose un &lt;em&gt;lock&lt;/em&gt; sur le segment, le processus doit être en root ;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SHM_UNLOCK&lt;/code&gt; : Enlève un &lt;em&gt;lock&lt;/em&gt; sur le segment, le processus doit être en root ;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IPC_STAT&lt;/code&gt; : Retourne les informations du segment et les place dans le buffer
&lt;code&gt;buf&lt;/code&gt;, le processus doit avoir accès en lecture au segment ;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IPC_SET&lt;/code&gt; : Définit l'identification utilisateur/groupe et les permissions
d'accès au segment, le processus doit être le propriétaire ou le créateur du segment,
ou être root ;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IPC_RMID&lt;/code&gt; : Supprime le segment de mémoire partagée.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;buf&lt;/code&gt; : Buffer pour les résultats.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pour attacher le segment de mémoire partagée à un pointeur et pour le détacher :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;shmat&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;shmid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;shmaddr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;shmflg&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;shmdt&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;shmaddr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;shmat&lt;/code&gt; : Retourne un pointeur vers le segment identifié par &lt;code&gt;shmid&lt;/code&gt; ;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shmdt&lt;/code&gt; : Détache le segment pointé par &lt;code&gt;shmaddr&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ces deux dernières fonctions ont pour effet de &lt;em&gt;mapper&lt;/em&gt; et &lt;em&gt;démapper&lt;/em&gt; le segment
dans l'espace d'adressage virtuel.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exemple d'utilisation :&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Voici un exemple de comment créer un segment de mémoire partagée :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;sys/types.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;sys/ipc.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;sys/shm.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;

&lt;span class="cp"&gt;#define SHM_SIZE    27&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;shmid_ds&lt;/span&gt; &lt;span class="n"&gt;shmid_ds&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;key_t&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5678&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;shmid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;shm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;    &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* create the shared memory segment */&lt;/span&gt;
    &lt;span class="n"&gt;shmid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;shmget&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SHM_SIZE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IPC_CREAT&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mo"&gt;0666&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shmid&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;perror&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;shmget&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;exit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* attach the shared memory segment in our address space */&lt;/span&gt;
    &lt;span class="n"&gt;shm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;shmat&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shmid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shm&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;perror&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;shmat&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;exit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* write data in our segment */&lt;/span&gt;
    &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;shm&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;z&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* now, we wait until the other process changes the first&lt;/span&gt;
&lt;span class="cm"&gt;     * character of our memory to &amp;#39;*&amp;#39;, indicating that it has&lt;/span&gt;
&lt;span class="cm"&gt;     * read what we put there.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;shm&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;*&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;sleep&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* detach the segment */&lt;/span&gt;
    &lt;span class="n"&gt;shmdt&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shm&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* remove it */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shmctl&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shmid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IPC_RMID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;shmid_ds&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;perror&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;shmctl&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;exit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;EXIT_SUCCESS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Et comment récupérer un segment de mémoire partagée dans un autre processus :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;sys/types.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;sys/ipc.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;sys/shm.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;

&lt;span class="cp"&gt;#define SHM_SIZE    27&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;key_t&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5678&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;shmid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;shm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* get the shared memory segment */&lt;/span&gt;
    &lt;span class="n"&gt;shmid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;shmget&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SHM_SIZE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mo"&gt;0666&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shmid&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;perror&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;shmget&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;exit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* attach the shared memory segment in our address space */&lt;/span&gt;
    &lt;span class="n"&gt;shm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;shmat&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shmid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shm&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;perror&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;shmat&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;exit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* read data */&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;shm&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;putchar&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;putchar&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* we readthe data, change the first byte */&lt;/span&gt;
    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;shm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;*&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* dettach segment */&lt;/span&gt;
    &lt;span class="n"&gt;shmdt&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shm&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;EXIT_SUCCESS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Si tout se passe bien, le second processus va afficher :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="go"&gt;abcdefghijklmnopqrstuvwxyz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Comme vous pouvez le voir, on utilise le premier caractère comme indicateur pour
prévenir le premier processus que les données ont été lues.&lt;/p&gt;
&lt;p&gt;On peut imaginer placer une structure dans cette mémoire avec dedans un entier
déterminant l'état de la mémoire :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;prêt pour la lecture ;&lt;/li&gt;
&lt;li&gt;en cours de lecture ;&lt;/li&gt;
&lt;li&gt;prêt pour l'écriture ;&lt;/li&gt;
&lt;li&gt;en cours d'écriture.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Mettre en place un tel système permet de faire un simili de concurrence entre deux
processus.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;C'est la fin de cet article, d'autres articles concernant le fonctionnement du
processeur x86 et d'autres composants du système d'exploitation (GDT, IDT, ...)
viendront s'ajouter à celui ci.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">David Delassus</dc:creator><pubDate>Sat, 09 Mar 2013 12:00:00 +0100</pubDate><guid>tag:www.lab-sl3.org,2013-03-09:articles/news/gestion-de-la-memoire-sur-larchitecture-x86.html</guid><category>os</category><category>x86</category></item><item><title>Fonctionnement d'un Garbage Collector</title><link>http://www.lab-sl3.org/articles/news/fonctionnement-dun-garbage-collector.html</link><description>&lt;p&gt;Avant tout, qu'est-ce qu'un &lt;strong&gt;Garbage Collector&lt;/strong&gt; ? La traduction en français nous donne : &lt;strong&gt;éboueur&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Le principe du &lt;em&gt;garbage collector&lt;/em&gt; est qu'il va aider à la gestion de la mémoire, à la manière d'un éboueur
qui nous aide dans l'évacuation de nos déchets.&lt;/p&gt;
&lt;p&gt;Attention ! Cela ne veut pas dire qu'il la gère à notre place, comme un éboueur ne viendra pas chez vous pour
sortir vos poubelles.&lt;/p&gt;
&lt;p&gt;En gros, lorsque l'on va allouer de la mémoire, le &lt;em&gt;garbage collector&lt;/em&gt; va en prendre note et garder une trace.
Lorsque l'on libère cette mémoire, le &lt;em&gt;garbage collector&lt;/em&gt; en est notifié. Le &lt;em&gt;garbage collector&lt;/em&gt; va permettre
de déterminer par qui est utilisé une certaine zone mémoire et lorsque celle-ci n'est plus utilisée par personne,
il la libère, imaginons cela :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gc_alloc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="cm"&gt;/* on alloue de la mémoire */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gc_ref&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;            &lt;span class="cm"&gt;/* on créé une nouvelle référence vers cette zone mémoire */&lt;/span&gt;

&lt;span class="cm"&gt;/* stuff with ptr */&lt;/span&gt;

&lt;span class="n"&gt;gc_unref&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;                      &lt;span class="cm"&gt;/* ptr n&amp;#39;utilise plus la zone mémoire, mais ptr2 continue de l&amp;#39;utiliser */&lt;/span&gt;

&lt;span class="cm"&gt;/* stuff with ptr2 */&lt;/span&gt;

&lt;span class="n"&gt;gc_unref&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;                     &lt;span class="cm"&gt;/* ptr2 ne l&amp;#39;utilise plus non plus, plus personne ne l&amp;#39;utilise, on peut la libérer */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Q: Quelle utilité de procéder comme cela ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;R: Et bien, cela permet plus de facilité dans le développement, on centralise en un point la gestion de la mémoire.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Autre exemple :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* sutff with ptr */&lt;/span&gt;
    &lt;span class="n"&gt;gc_unref&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gc_alloc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

    &lt;span class="n"&gt;func&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gc_ref&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="cm"&gt;/* on passe une référence à la fonction */&lt;/span&gt;

    &lt;span class="cm"&gt;/* ici notre pointeur est encore valide ! */&lt;/span&gt;

    &lt;span class="cm"&gt;/* stuff with ptr */&lt;/span&gt;

    &lt;span class="n"&gt;gc_unref&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* ptr n&amp;#39;est plus valide */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Implémenter un GC en C&lt;/h2&gt;
&lt;p&gt;Nous allons implémenter 4 fonctions pour notre &lt;em&gt;GC&lt;/em&gt; (&lt;strong&gt;G&lt;/strong&gt;arbage &lt;strong&gt;C&lt;/strong&gt;ollector) :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;gc_alloc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;sz&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;               &lt;span class="cm"&gt;/* allocation de mémoire */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;gc_realloc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;sz&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="cm"&gt;/* réallocation de mémoire */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;gc_ref&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;                &lt;span class="cm"&gt;/* référencement d&amp;#39;un pointeur */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;gc_unref&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;               &lt;span class="cm"&gt;/* déréférencement d&amp;#39;un pointeur */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Le nécessaire&lt;/h3&gt;
&lt;p&gt;Pour cela, on aura besoin d'une liste qui comprendra notre pointeur, et son nombre de référence :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lors de l'allocation, le nombre de référence est à 1 ;&lt;/li&gt;
&lt;li&gt;lors d'un référencement, on incrémente ce nombre ;&lt;/li&gt;
&lt;li&gt;lors d'un déréférencement, on décrémente ce nombre ;&lt;/li&gt;
&lt;li&gt;si ce nombre arrive à 0, plus personne ne l'utilise, on libère la mémoire.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;On aurait donc :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;gc_list_t&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;refcount&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;gc_list_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;gc_list_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;prev&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;gc_list_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* une liste circulaire, c&amp;#39;est plus simple */&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Une API pour manipuler la liste du GC&lt;/h3&gt;
&lt;p&gt;Je vous la donne telle quelle, car ce n'est pas l'objet de l'article :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;gc_list_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;_gc_list_append&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;gc_list_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* initialize head list */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="cm"&gt;/* the head is the element */&lt;/span&gt;
        &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* the next element is the head */&lt;/span&gt;
        &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;prev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* the previous element is the head */&lt;/span&gt;

        &lt;span class="cm"&gt;/* this is a circular list, there is no NULL prev/next */&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="cm"&gt;/* head already initialized, add it to the end */&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/* the head don&amp;#39;t change */&lt;/span&gt;
        &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/* the next element is the head, so element is at the end of the list */&lt;/span&gt;
        &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;prev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;prev&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/* the previous element of the head become the current element&amp;#39;s previous */&lt;/span&gt;

        &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;prev&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/* the next element of the head&amp;#39;s previous (was the head) become the current element */&lt;/span&gt;
        &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;prev&lt;/span&gt;       &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/* the previous element of the head becomes the current element */&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;_gc_list_remove&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;gc_list_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;prev&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* the next element of the previous one becomes the next of the current element */&lt;/span&gt;
    &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;prev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;prev&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* the previous element of the next one becomes the previous of the current element */&lt;/span&gt;

    &lt;span class="cm"&gt;/* so element is not linked anymore in the list */&lt;/span&gt;

    &lt;span class="cm"&gt;/* do not forget to set head at NULL if it was the head. */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* then free it */&lt;/span&gt;
    &lt;span class="n"&gt;free&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;gc_list_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;_gc_list_find&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;gc_list_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* do the search while we are not on the head */&lt;/span&gt;
    &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* if we reach the head, we walked trough the whole list&lt;/span&gt;
&lt;span class="cm"&gt;     * without any success :(&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Implémentation de l'allocation&lt;/h3&gt;
&lt;p&gt;Que dois faire notre allocateur ?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;allouer la mémoire, comme demandé ;&lt;/li&gt;
&lt;li&gt;allouer de la place dans la liste interne ;&lt;/li&gt;
&lt;li&gt;initialiser le compteur de référence à 1 ;&lt;/li&gt;
&lt;li&gt;ajouter l'élement dans la liste ;&lt;/li&gt;
&lt;li&gt;retourner le pointeur vers la mémoire.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Voyons cela en C :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;gc_alloc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;sz&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sz&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;gc_list_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;gc_list_t&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

        &lt;span class="cm"&gt;/* if we can&amp;#39;t allocate place for the element in the list, free memory and return NULL */&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;free&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="cm"&gt;/* initialize element */&lt;/span&gt;
        &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;     &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;refcount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="cm"&gt;/* add it to the list */&lt;/span&gt;
        &lt;span class="n"&gt;_gc_list_append&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Concernant la réallocation, que doit-on faire ?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rechercher le pointeur dans notre liste ;&lt;/li&gt;
&lt;li&gt;si on ne le trouve pas, on retourne NULL ;&lt;/li&gt;
&lt;li&gt;si on le trouve, on réalloue avec &lt;code&gt;realloc()&lt;/code&gt; ;&lt;/li&gt;
&lt;li&gt;on retourne le nouveau pointeur.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ce qui donne :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;gc_realloc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;sz&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;gc_list_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* if addr is NULL, treat it as allocation */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;gc_alloc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sz&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* if size is 0, treat it as unref */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sz&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;gc_unref&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* so now, search the address in the list */&lt;/span&gt;
    &lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_gc_list_find&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* element found */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* realloc it */&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;realloc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sz&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="cm"&gt;/* if it doesn&amp;#39;t fail */&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="cm"&gt;/* assign the new pointer (NB: realloc may return a different pointer) */&lt;/span&gt;
            &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="cm"&gt;/* when realloc returns NULL, the old pointer isn&amp;#39;t freed or moved,&lt;/span&gt;
&lt;span class="cm"&gt;         * so we don&amp;#39;t remove it from our list.&lt;/span&gt;
&lt;span class="cm"&gt;         */&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* element not found */&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Référencement, déréférencement&lt;/h3&gt;
&lt;p&gt;Le référencement est plutôt simple :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;on cherche le pointeur dans notre liste ;&lt;/li&gt;
&lt;li&gt;si on ne le trouve pas, on retourne NULL ;&lt;/li&gt;
&lt;li&gt;si on le trouve, on incrémente son compteur de référence ;&lt;/li&gt;
&lt;li&gt;on retourne le pointeur.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;On obtient donc :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;gc_ref&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;gc_list_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_gc_list_find&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;refcount&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pour le déréférencement, c'est sensiblement pareil :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;on cherche le pointeur dans notre liste ;&lt;/li&gt;
&lt;li&gt;si on ne le trouve pas, on fait rien ;&lt;/li&gt;
&lt;li&gt;si on le trouve on décrémente son compteur de référence ;&lt;/li&gt;
&lt;li&gt;si le compteur de référence atteint 0, alors on libère la mémoire.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ce qui donne :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;gc_unref&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;gc_list_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* if address is NULL, do nothing */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_gc_list_find&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* if the element isn&amp;#39;t found, do nothing */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* now decrement refcount */&lt;/span&gt;
    &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;refcount&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* if refcount reaches 0 */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;refcount&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* free memory */&lt;/span&gt;
        &lt;span class="n"&gt;free&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;_gc_list_remove&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Voilà un petit &lt;em&gt;Garbage Collector&lt;/em&gt; qui vous facilitera la vie, et qui vous en apprend un peu plus sur le fonctionnement de ce dernier.&lt;/p&gt;
&lt;p&gt;Vous devez toujours gérer votre mémoire, ne pas la laisser s'entasser comme des poubelles qu'on ne sort pas. Le &lt;em&gt;GC&lt;/em&gt; vous aide à la gérer, il ne le fait pas à votre place.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">David Delassus</dc:creator><pubDate>Fri, 01 Mar 2013 18:00:00 +0100</pubDate><guid>tag:www.lab-sl3.org,2013-03-01:articles/news/fonctionnement-dun-garbage-collector.html</guid></item><item><title>Fonctionnement et implémentation d'un gestionnaire d'allocation en C</title><link>http://www.lab-sl3.org/articles/news/fonctionnement-et-implementation-dun-gestionnaire-dallocation-en-c.html</link><description>&lt;p&gt;Un des points importants en programmation bas niveau est la gestion de la mémoire.
Ainsi bien comprendre le fonctionnement du gestionnaire de mémoire (malloc, free, etc) est nécessaire.&lt;/p&gt;
&lt;p&gt;Au travers de cet article, nous explorerons comment le système d'exploitation
gère la mémoire (mémoire segmentée, paginée, ...) et comment écrire notre propre
gestionnaire de mémoire (malloc, calloc, realloc, free).&lt;/p&gt;
&lt;h2&gt;Le fonctionnement de l'allocation dynamique&lt;/h2&gt;
&lt;p&gt;Pour rappel, la structure d'un programme en mémoire est la suivante :&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="Schéma de la structure d'un programme" src="http://ompldr.org/vaGZrNA" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;L'allocation dynamique se fait au moyen de l'appel système &lt;strong&gt;sbrk&lt;/strong&gt;. Cet appel
système prend en paramètre la taille des données à allouer et renvoie l'adresse de
ces données sur le tas (&lt;em&gt;heap&lt;/em&gt; en anglais).&lt;/p&gt;
&lt;p&gt;Lorsque l'on appelle &lt;strong&gt;sbrk&lt;/strong&gt;, ce dernier ajoute la taille des données à allouer
au sommet du tas :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;HeapSize&lt;/span&gt;  &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;4096&lt;/span&gt;
&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;HeapStart&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;heap&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="n"&gt;after&lt;/span&gt; &lt;span class="n"&gt;BSS&lt;/span&gt; &lt;span class="n"&gt;segment&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;HeapEnd&lt;/span&gt;   &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;HeapStart&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;HeapSize&lt;/span&gt;

&lt;span class="n"&gt;syscall&lt;/span&gt; &lt;span class="n"&gt;sbrk&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;begin&lt;/span&gt;
    &lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;HeapEnd&lt;/span&gt;

    &lt;span class="n"&gt;HeapEnd&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;C'est cet appel système que la fonction &lt;code&gt;malloc()&lt;/code&gt; utilise.&lt;/p&gt;
&lt;h2&gt;Créer son propre gestionnaire de mémoire&lt;/h2&gt;
&lt;p&gt;Nous allons donc utiliser l'appel système &lt;strong&gt;sbrk&lt;/strong&gt; pour allouer de la mémoire.
Le problème suivant se pose, comment allons nous désallouer la mémoire ?&lt;/p&gt;
&lt;p&gt;Pour cela, nous allons ajouter une en-tête à chacune de nos allocations mémoire,
précisant la taille du bloc de donnée et s'il est occupé. Pour désallouer un bloc
de données, il suffira de préciser que ce bloc est libre :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;block&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt;
&lt;span class="n"&gt;begin&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;used&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Allouer de la mémoire&lt;/h3&gt;
&lt;p&gt;Le fonctionnement de &lt;code&gt;malloc()&lt;/code&gt; sera de chercher le premier bloc de données
libre dont la taille est supérieure ou égale à la taille que l'on veut allouer.
On définit ensuite ce bloc comme étant occupé.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* informations sur le tas */&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;HeapStart&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;HeapEnd&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/* notre en-tête */&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;malloc_header_t&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;used&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="cm"&gt;/* la taille de notre en-tête est donc de 32 bits, soit un int */&lt;/span&gt;

&lt;span class="cm"&gt;/* on veut qu&amp;#39;un bloc ait une taille minimale */&lt;/span&gt;
&lt;span class="cp"&gt;#define MALLOC_MINSIZE 16&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;malloc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;sz&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;malloc_header_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;bl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* taille totale des données à allouer */&lt;/span&gt;

    &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;realsize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sz&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;malloc_header_t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* pour des raisons de performances, on va aligner la taille à&lt;/span&gt;
&lt;span class="cm"&gt;     * allouer sur le multiple de 8 supérieur&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;realsize&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;MALLOC_MINSIZE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;realsize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;realsize&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;MALLOC_MINSIZE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* on initialise d&amp;#39;abord le tas si cela n&amp;#39;a pas déjà été fait */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HeapStart&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;HeapStart&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sbrk&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;realsize&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="cm"&gt;/* en cas d&amp;#39;erreur, sbrk() renvoie -1 */&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HeapStart&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="cm"&gt;/* on défini la fin du tas */&lt;/span&gt;
        &lt;span class="n"&gt;HeapEnd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;realsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="cm"&gt;/* on déclare notre premier bloc */&lt;/span&gt;
        &lt;span class="n"&gt;bl&lt;/span&gt;       &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;malloc_header_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;HeapStart&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;bl&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;realsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;bl&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;used&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* l&amp;#39;allocation ne se fait pas tout de suite */&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* on cherche le premier bloc de données libre de taille supérieure ou égale */&lt;/span&gt;
        &lt;span class="n"&gt;bl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;malloc_header_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;HeapStart&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bl&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;used&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;bl&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;realsize&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="cm"&gt;/* on passe au bloc suivant */&lt;/span&gt;
            &lt;span class="n"&gt;bl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;malloc_header_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bl&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;bl&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

            &lt;span class="cm"&gt;/* si on a atteint la fin du tas, alors on en redemande */&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bl&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;malloc_header_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;HeapEnd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;HeapEnd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sbrk&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;realsize&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HeapEnd&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;

                &lt;span class="cm"&gt;/* on crée notre nouveau bloc */&lt;/span&gt;
                &lt;span class="n"&gt;bl&lt;/span&gt;       &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;malloc_header_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;HeapEnd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;bl&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;realsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;bl&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;used&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* l&amp;#39;allocation ne se fait pas tout de suite */&lt;/span&gt;

                &lt;span class="cm"&gt;/* on redéfinit la fin du tas */&lt;/span&gt;
                &lt;span class="n"&gt;HeapEnd&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;realsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* un bloc de données de taille supérieure ou égale a été trouvé */&lt;/span&gt;

    &lt;span class="cm"&gt;/* si la différence entre la taille du bloc que l&amp;#39;on a trouvé et&lt;/span&gt;
&lt;span class="cm"&gt;     * la taille des données que l&amp;#39;on veut est supérieure à la taille&lt;/span&gt;
&lt;span class="cm"&gt;     * minimale d&amp;#39;un bloc de données, alors on découpe le bloc pour&lt;/span&gt;
&lt;span class="cm"&gt;     * économiser la mémoire du tas.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bl&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;realsize&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;MALLOC_MINSIZE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;malloc_header_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;newbl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="cm"&gt;/* grâce à l&amp;#39;alignement fait au début, nos blocs ont tous une taille&lt;/span&gt;
&lt;span class="cm"&gt;         * en multiple de 8.&lt;/span&gt;
&lt;span class="cm"&gt;         */&lt;/span&gt;
        &lt;span class="n"&gt;newbl&lt;/span&gt;       &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;malloc_header_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;bl&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;realsize&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;newbl&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bl&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;realsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;newbl&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;used&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="cm"&gt;/* on redéfini notre bloc actuel */&lt;/span&gt;
        &lt;span class="n"&gt;bl&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;realsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* on peut enfin définir notre bloc comme étant alloué */&lt;/span&gt;
    &lt;span class="n"&gt;bl&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;used&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* et on retourne un pointeur sur la mémoire qui suit notre en-tête */&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bl&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;malloc_header_t&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Désallouer de la mémoire&lt;/h3&gt;
&lt;p&gt;Pour la déallocation, il suffira de définir le bloc actuel comme étant libre.
Et si le bloc suivant est également libre, on ajoute sa taille au bloc actuel,
afin d'optimiser la gestion du tas :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;malloc_header_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;bl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;malloc_header_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nextbl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* On récupère notre en-tête */&lt;/span&gt;
    &lt;span class="n"&gt;bl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;malloc_header_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;malloc_header_t&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

    &lt;span class="cm"&gt;/* On merge le bloc nouvellement libéré avec le bloc suivant ci celui-ci&lt;/span&gt;
&lt;span class="cm"&gt;     * est aussi libre&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;nextbl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;malloc_header_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;bl&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;bl&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;nextbl&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;malloc_header_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;HeapEnd&lt;/span&gt;
            &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;nextbl&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;used&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;bl&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;nextbl&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* On libère le bloc alloué */&lt;/span&gt;
    &lt;span class="n"&gt;bl&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;used&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Réallouer de la mémoire&lt;/h3&gt;
&lt;p&gt;Maintenant que nous avons les bases de notre gestionnaire, il serait bien de le
compléter avec des fonctions telles que &lt;code&gt;realloc()&lt;/code&gt; et &lt;code&gt;calloc()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Rappelons le fonctionnement de &lt;code&gt;realloc()&lt;/code&gt; :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;realloc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;new_sz&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;Si &lt;code&gt;addr&lt;/code&gt; est égal à &lt;code&gt;NULL&lt;/code&gt;, le fonctionnement est le même que &lt;code&gt;malloc()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Si &lt;code&gt;new_sz&lt;/code&gt; est égal à &lt;code&gt;0&lt;/code&gt;, le fonctionnement est le même que &lt;code&gt;free()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Dans le cas contraire, on alloue le nouvel espace, on copie la mémoire de l'un vers l'autre, et on libère le précédent.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Voici ce que cela donne :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;realloc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;new_sz&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;new_ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_sz&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_sz&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;free&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* on alloue le nouvel espace mémoire */&lt;/span&gt;
    &lt;span class="n"&gt;new_ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_sz&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_ptr&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;malloc_header_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;bl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="cm"&gt;/* on récupère la taille de notre précédent pointeur */&lt;/span&gt;
        &lt;span class="n"&gt;bl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;malloc_header_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;malloc_header_t&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

        &lt;span class="cm"&gt;/* on recopie la mémoire */&lt;/span&gt;
        &lt;span class="n"&gt;memcpy&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bl&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;malloc_header_t&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;new_ptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Et pour finir&lt;/h3&gt;
&lt;p&gt;Il ne manque plus qu'une fonction à notre gestionnaire, celle ci est plutôt simple :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;calloc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;nmemb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;membsz&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nmemb&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;membsz&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;memset&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nmemb&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;membsz&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;L'implémentation d'un gestionnaire de mémoire n'est donc pas compliqué. On comprend
maintenant mieux le fonctionnement des fuites de mémoire, et les gros risques qu'elle
peut entraîner.&lt;/p&gt;
&lt;p&gt;En effet, le tas et la pile partageant le même registre, si l'on ne libère pas la
mémoire, on diminue la taille de la pile, et nous risquons de faire planter gravement
le programme (empiler des données risquerait d'écrire par dessus de la mémoire allouée
dynamiquement).&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">David Delassus</dc:creator><pubDate>Mon, 11 Feb 2013 18:00:00 +0100</pubDate><guid>tag:www.lab-sl3.org,2013-02-11:articles/news/fonctionnement-et-implementation-dun-gestionnaire-dallocation-en-c.html</guid><category>c</category><category>os</category></item><item><title>Le parallélisme avec fork()</title><link>http://www.lab-sl3.org/articles/news/le-parallelisme-avec-fork.html</link><description>&lt;p&gt;Dans mon &lt;a href="http://www.lab-sl3.org/articles/news/quest-ce-quun-processus.html"&gt;article précédent&lt;/a&gt;,
je vous ai parlé de processus. Cet article lui fait directement suite, car nous parlerons
ici de parallélisme. Nous aborderons la définition de parallélisme, et son implémentation en
langage C.&lt;/p&gt;
&lt;h2&gt;Le parallélisme, c'est quoi ?&lt;/h2&gt;
&lt;p&gt;On sait que le système d'exploitation exécute différents processus en &lt;strong&gt;parallèle&lt;/strong&gt;
grâce à l'ordonnanceur. Le parallélisme, c'est l'exécution &lt;strong&gt;simultanée&lt;/strong&gt; (en parallèle)
de différentes parties du même programme.&lt;/p&gt;
&lt;p&gt;Le fonctionnement est simple, le programme aura deux processus associés, au lieu
d'un. Le processus principal (créé par le système d'exploitation au lancement du
programme) est appelé &lt;strong&gt;processus père&lt;/strong&gt;, et le processus créé par le programme
(en réalité, le programme demande au système d'exploitation la création d'un nouveau
processus) est appelé &lt;strong&gt;processus fils&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Un processus père peut avoir plusieurs processus fils, mais un processus fils ne
possède qu'un &lt;strong&gt;unique&lt;/strong&gt; processus père.&lt;/p&gt;
&lt;p&gt;Le processus fils, au même titre qu'un processus normal, possède sa propre plage
mémoire, son propre contexte, son propre identifiant, etc.&lt;/p&gt;
&lt;h2&gt;Les appels systèmes&lt;/h2&gt;
&lt;p&gt;Avant de continuer, il est nécessaire de connaître la notion &lt;strong&gt;d'appel système&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Lorsque le système d'exploitation créé un processus, ce dernier s'exécute en &lt;strong&gt;mode
utilisateur&lt;/strong&gt;. C'est à dire qu'il n'aura pas accès à une autre plage mémoire que
celles qui lui sont allouées, il n'aura pas accès au matériel, bref il est cloisonné.
C'est le &lt;strong&gt;niveau d'exécution 3&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Ceci n'est pas très pratique pour le développement, alors que le système d'exploitation,
lui s'exécute sans aucune restriction (&lt;strong&gt;niveau d'exécution 0&lt;/strong&gt;).&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="schéma des niveau d'exécution" src="http://www.jamesmolloy.co.uk/images/rings.png" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Plus le niveau d'exécution est bas, plus le processus lancé dans ce niveau d'exécution
aura de privilèges. Il est possible de configurer ces privilèges au niveau du &lt;em&gt;CPU&lt;/em&gt;,
mais cela ne fait pas partie de cet article. Sachez juste que dans un système à
mémoire paginée, il est compliqué d'utiliser le niveau d'exécution 1 et 2. On pourrait
cependant imaginer la configuration suivante :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;niveau 0 : mode noyau, tout est permis ;&lt;/li&gt;
&lt;li&gt;niveau 1 : pour les drivers, les I/O ne sont plus permises pour les niveaux supérieurs ;&lt;/li&gt;
&lt;li&gt;niveau 2 : pour les drivers vidéos, l'accès à la mémoire vidéo n'est plus permise pour les niveaux supérieurs ;&lt;/li&gt;
&lt;li&gt;niveau 3 : mode utilisateur, pour les applications, les services, ... rien n'est permis.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pour palier ce problème de restriction, le noyau fournis au reste du système une
&lt;em&gt;API&lt;/em&gt; pour exécuter &lt;strong&gt;temporairement&lt;/strong&gt; un code en mode noyau (niveau d'exécution
0). On appelle cela un appel système (&lt;em&gt;syscall&lt;/em&gt; en anglais).&lt;/p&gt;
&lt;p&gt;Pour cela, le noyau enregistre dans son &lt;em&gt;IDT&lt;/em&gt; (&lt;em&gt;I_nterrupt _D_escriptor _T_able,
l'IVT du mode protégé) une nouvelle interruption (pour le _DOS&lt;/em&gt; c'est l'interruption
&lt;strong&gt;21h&lt;/strong&gt;, pour les unices, c'est l'interruption &lt;strong&gt;80h&lt;/strong&gt;). Selon la valeur des
registres lors de l'exécution de l'interruption, telle ou telle fonction sera
exécutée. Par exemple, pour &lt;strong&gt;Linux&lt;/strong&gt; :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;[SECTION .text]&lt;/span&gt;

&lt;span class="k"&gt;[GLOBAL _start]&lt;/span&gt;

&lt;span class="err"&gt;_start:&lt;/span&gt;
    &lt;span class="err"&gt;mov&lt;/span&gt; &lt;span class="err"&gt;edx,&lt;/span&gt; &lt;span class="err"&gt;len&lt;/span&gt;    &lt;span class="c1"&gt;; Longueur du message a afficher&lt;/span&gt;
    &lt;span class="err"&gt;mov&lt;/span&gt; &lt;span class="err"&gt;ecx,&lt;/span&gt; &lt;span class="err"&gt;msg&lt;/span&gt;    &lt;span class="c1"&gt;; Adresse du message&lt;/span&gt;
    &lt;span class="err"&gt;mov&lt;/span&gt; &lt;span class="err"&gt;ebx,&lt;/span&gt; &lt;span class="err"&gt;1&lt;/span&gt;      &lt;span class="c1"&gt;; on ecrit dans le descripteur de fichier 1 (stdout)&lt;/span&gt;
    &lt;span class="err"&gt;mov&lt;/span&gt; &lt;span class="err"&gt;eax,&lt;/span&gt; &lt;span class="err"&gt;4&lt;/span&gt;      &lt;span class="c1"&gt;; appel systeme numero 4 (write)&lt;/span&gt;
    &lt;span class="err"&gt;int&lt;/span&gt; &lt;span class="err"&gt;0x80&lt;/span&gt;        &lt;span class="c1"&gt;; execution de l&amp;#39;appel systeme&lt;/span&gt;

    &lt;span class="err"&gt;mov&lt;/span&gt; &lt;span class="err"&gt;eax,&lt;/span&gt; &lt;span class="err"&gt;1&lt;/span&gt;      &lt;span class="c1"&gt;; appel system numero 1 (exit)&lt;/span&gt;
    &lt;span class="err"&gt;int&lt;/span&gt; &lt;span class="err"&gt;0x80&lt;/span&gt;        &lt;span class="c1"&gt;; execution de l&amp;#39;appel systeme&lt;/span&gt;

&lt;span class="k"&gt;[SECTION .data]&lt;/span&gt;

&lt;span class="err"&gt;msg:&lt;/span&gt; &lt;span class="err"&gt;db&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;Hello,&lt;/span&gt; &lt;span class="err"&gt;world!&amp;#39;,&lt;/span&gt; &lt;span class="err"&gt;0xA&lt;/span&gt;  &lt;span class="c1"&gt;; notre message&lt;/span&gt;
&lt;span class="err"&gt;len:&lt;/span&gt; &lt;span class="err"&gt;equ&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="err"&gt;-&lt;/span&gt; &lt;span class="err"&gt;msg&lt;/span&gt;              &lt;span class="c1"&gt;; longueur du message&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Créer un processus avec fork()&lt;/h2&gt;
&lt;p&gt;La fonction &lt;code&gt;fork()&lt;/code&gt; de la librairie standard du C est en réalité un appel
système (l'appel système 2 sous &lt;em&gt;Linux&lt;/em&gt;). Voici un exemple simple d'utilisation :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;pid_t&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fork&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Father %ld: child process created &amp;lt;%ld&amp;gt;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;getpid&lt;/span&gt; &lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;sleep&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Child %ld: hello world!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;getpid&lt;/span&gt; &lt;span class="p"&gt;());&lt;/span&gt;
        &lt;span class="n"&gt;sleep&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;fprintf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Can&amp;#39;t fork()!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;exit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;EXIT_SUCCESS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;L'appel système &lt;code&gt;fork()&lt;/code&gt; va créer un nouveau processus, &lt;strong&gt;à partir du processus
père&lt;/strong&gt;, et le lancer. Dans le processus père, il renverra l'identifiant du nouveau
processus, dans le processus fils, il renverra 0, en cas d'erreur, il renvoie -1
et &lt;code&gt;errno&lt;/code&gt; est défini.&lt;/p&gt;
&lt;h2&gt;Fonctionnement de fork()&lt;/h2&gt;
&lt;p&gt;J'insiste sur ma phrase précédente :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;L'appel système &lt;code&gt;fork()&lt;/code&gt; va créer un nouveau processus, &lt;strong&gt;à partir du processus père&lt;/strong&gt;...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;Réfléchissons... Je créé un nouveau processus à partir du premier. Il me suffirait
de copier la zone mémoire du premier processus dans la zone mémoire du second !&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Ça marche, mais si votre programme fait 4 Go ?&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Hmm... Comme le code est identique pour les deux processus, il n'est pas nécessaire
de le copier ! On copiera donc seulement le segment de données et de pile.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;C'est déjà mieux, on ne peut pas mieux faire ?&lt;/p&gt;
&lt;p&gt;&lt;em&gt;C'est vrai que le segment de données contient les données statiques du programme.
C'est donc inutile aussi de les copier, vu que ces données sont statiques !&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;On progresse. En réalité, &lt;code&gt;fork()&lt;/code&gt; ne va rien copier du tout ! Il va appliquer
le principe de &lt;strong&gt;copie sur écriture&lt;/strong&gt; (&lt;em&gt;copy-on-write&lt;/em&gt; en anglais). Avec ce
procédé, les deux processus partagerons les mêmes données, jusqu'à ce que l'un
d'entre eux modifiera ces mêmes données. À ce moment précis, les données vont être
copiées dans le processus qui effectue la modification avant d'appliquer cette
dernière.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="schéma du fonctionnement du copy-on-write" src="http://ompldr.org/vaGFmNg/copy-on-write.png" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;h2&gt;La communication inter-processus&lt;/h2&gt;
&lt;p&gt;L'intérêt du parallélisme, c'est de diviser l'application en différents contextes
capables de communiquer entre eux. Prenons un exemple simple, un installeur.&lt;/p&gt;
&lt;p&gt;L'installeur va installer le logiciel (on s'en doutait...) et en parallèle notifier
l'utilisateur de l'avancement de l'installation avec une barre de progression.&lt;/p&gt;
&lt;p&gt;C'est simpliste, mais le problème est là. Comment faire communiquer le processus
chargé de l'installation avec le processus chargé de la progression de la barre ?&lt;/p&gt;
&lt;h3&gt;Les tubes&lt;/h3&gt;
&lt;p&gt;Un moyen simple, mais efficace, deux faire communiquer deux processus, ce sont
&lt;strong&gt;les tubes&lt;/strong&gt; (&lt;em&gt;pipe&lt;/em&gt; en anglais) :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; cat file.txt | grep &lt;span class="s2"&gt;&amp;quot;pattern&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Dans l'exemple ci-dessus, la sortie de &lt;code&gt;cat&lt;/code&gt; est redirigée sur l'entrée de &lt;code&gt;grep&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Dans l'exemple ci-dessous, on voit la création d'un tube, et son usage avec &lt;code&gt;fork()&lt;/code&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;errno.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fds&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="kt"&gt;pid_t&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pipe&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fds&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;fprintf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;can&amp;#39;t create pipe : %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;strerror&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;errno&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="n"&gt;exit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* fds[0] : flux d&amp;#39;entree&lt;/span&gt;
&lt;span class="cm"&gt;     * fds[1] : flux de sortie&lt;/span&gt;
&lt;span class="cm"&gt;     *&lt;/span&gt;
&lt;span class="cm"&gt;     * Tout ce qui est ecris dans fds[1] peut etre lu dans fds[0]&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;

    &lt;span class="cm"&gt;/* on fork ! */&lt;/span&gt;
    &lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fork&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;fprintf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;can&amp;#39;t fork : %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;strerror&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;errno&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

        &lt;span class="n"&gt;close&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fds&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="n"&gt;close&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fds&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

        &lt;span class="n"&gt;exit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* processus fils */&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fdopen&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fds&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="cm"&gt;/* on encapsule notre sortie dans un stream */&lt;/span&gt;

        &lt;span class="n"&gt;close&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fds&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt; &lt;span class="cm"&gt;/* on ferme l&amp;#39;entree car inutile ici */&lt;/span&gt;

        &lt;span class="cm"&gt;/* on envoie une chaine dans le tube */&lt;/span&gt;
        &lt;span class="n"&gt;fprintf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;hello world!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;fclose&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* processus pere */&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

        &lt;span class="kt"&gt;FILE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fdopen&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fds&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;r&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="cm"&gt;/* on encapsule l&amp;#39;entree dans un stream */&lt;/span&gt;

        &lt;span class="n"&gt;close&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fds&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt; &lt;span class="cm"&gt;/* on ferme la sortie car inutile ici */&lt;/span&gt;

        &lt;span class="cm"&gt;/* on lit une chaine depuis le tube */&lt;/span&gt;
        &lt;span class="n"&gt;fread&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Received from child %ld : %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;fclose&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;EXIT_SUCCESS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;On peut maintenant faire communiquer deux processus via les tubes. Avec l'utilisation
de &lt;code&gt;(f)write()&lt;/code&gt; et &lt;code&gt;(f)read()&lt;/code&gt;, on peut faire transiter n'importe quel type de
données (le buffer étant de type &lt;code&gt;void *&lt;/code&gt;). Si vous voulez faire transiter des
données complexes, je vous conseil de les encapsuler dans une structure (attention
aux pointeurs !). Avec l'utilisation de &lt;code&gt;select()&lt;/code&gt;, vous pouvez faire des choses
encore plus poussées, je vous conseil donc également la lecture du manuel concernant
cette fonction (&lt;code&gt;man 3 select&lt;/code&gt;).&lt;/p&gt;
&lt;h3&gt;Les signaux&lt;/h3&gt;
&lt;p&gt;Dans un système &lt;em&gt;Unix&lt;/em&gt;, chaque processus peut recevoir des signaux provenant du
système d'exploitation. Un signal est un message envoyé par le système d'exploitation
pour prévenir le processus d'un événement qu'il doit gérer. Par exemple, si le
système envoie le signal &lt;strong&gt;SIGSEGV&lt;/strong&gt; à notre programme, c'est pour le notifier qu'il
a tenté d'accéder à une zone de la mémoire qui lui est interdite (erreur de segmentation),
le programme doit donc quitter sans attendre dès la réception de ce signal.&lt;/p&gt;
&lt;p&gt;Voici la manière la plus simple de réceptionner un signal :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;signal.h&amp;gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* fonction qui gère notre signal */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;sig_handler&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sig&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Signal received : %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sig&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* cette structure va nous permettre de definir notre gestionnaire de signal */&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sigaction&lt;/span&gt; &lt;span class="n"&gt;mysighdlr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;mysighdlr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sa_handler&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sig_handler&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/* le gestionnaire */&lt;/span&gt;
    &lt;span class="n"&gt;mysighdlr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sa_flags&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="cm"&gt;/* on ignore ce champ pour cet exemple */&lt;/span&gt;

    &lt;span class="cm"&gt;/* sa_mask correspond au masque des signaux à bloquer pendant l&amp;#39;execution&lt;/span&gt;
&lt;span class="cm"&gt;     * de notre gestionnaire, ici on en bloque aucun&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="n"&gt;sigemptyset&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mysighdlr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sa_mask&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* on mets en place notre gestionnaire */&lt;/span&gt;
    &lt;span class="n"&gt;sigaction&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SIGINT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;sighdlr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="cm"&gt;/* SIGINT  - provoque l&amp;#39;interruption du programme (CTRL-C) */&lt;/span&gt;
    &lt;span class="n"&gt;sigaction&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SIGQUIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;sighdlr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="cm"&gt;/* SIGQUIT - provoque l&amp;#39;arret du programme avec production d&amp;#39;un core-dump */&lt;/span&gt;
    &lt;span class="n"&gt;sigaction&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SIGTERM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;sighdlr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="cm"&gt;/* SIGTERM - provoque l&amp;#39;interruption du programme */&lt;/span&gt;

    &lt;span class="cm"&gt;/* boucle infinie, il faudra tuer le processus avec : kill -HUP */&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vous pouvez envoyez des signaux à l'aide du logiciel &lt;strong&gt;HTop&lt;/strong&gt; pour voir l'effet que cela a sur votre programme.&lt;/p&gt;
&lt;p&gt;Maintenant que l'on sait réceptionner des signaux, il faudrait savoir comment en envoyer.
La réponse nous est donnée dans la section 2 du manuel (&lt;code&gt;man 2 kill&lt;/code&gt;) :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;sys/types.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;signal.h&amp;gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Envoi le signal `sig` au processus `pid` */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;kill&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pid_t&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sig&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pour parfaire notre communication inter-processus (&lt;em&gt;IPC&lt;/em&gt; en anglais), il ne reste
plus qu'un point à aborder : mettre tout ça en commun.&lt;/p&gt;
&lt;p&gt;Voici donc un petit exemple :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;sys/types.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;signal.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;errno.h&amp;gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* cette variable globale va nous permettre d&amp;#39;attendre la reception d&amp;#39;un signal */&lt;/span&gt;
&lt;span class="k"&gt;volatile&lt;/span&gt; &lt;span class="kt"&gt;sig_atomic_t&lt;/span&gt; &lt;span class="n"&gt;usr_interrupt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/* le gestionnaire du signal SIGUSR1 va mettre le precedent booleen a vrai */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;sig_handler&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sig&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;usr_interrupt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* fonction du processus fils */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;child_function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;I&amp;#39;m a child &amp;lt;%ld&amp;gt; !&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;getpid&lt;/span&gt; &lt;span class="p"&gt;());&lt;/span&gt;

    &lt;span class="cm"&gt;/* on envoi le signal au processus pere */&lt;/span&gt;
    &lt;span class="n"&gt;kill&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;getppid&lt;/span&gt; &lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;SIGUSR1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Good bye!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;exit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EXIT_SUCCESS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sigaction&lt;/span&gt; &lt;span class="n"&gt;sighdlr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;pid_t&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* on cree le gestionnaire du signal */&lt;/span&gt;
    &lt;span class="n"&gt;sighdlr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sa_handler&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sig_handler&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;sighdlr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sa_flags&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* on veut bloquer tout les signaux pendant l&amp;#39;execution de notre gestionnaire */&lt;/span&gt;
    &lt;span class="n"&gt;sigfillset&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;sighdlr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sa_mask&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;sigaction&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SIGUSR1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;sighdlr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* maintenant, on fork comme on sait le faire */&lt;/span&gt;
    &lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fork&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;fprintf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;can&amp;#39;t fork : %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;strerror&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;errno&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="n"&gt;exit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;child_function&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="cm"&gt;/* ne retourne pas */&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* tant que usr_interrupt est faux, on attend */&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;usr_interrupt&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;i&amp;#39;m done.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;EXIT_SUCCESS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Dans l'exemple ci-dessus, lorsque le fils va se lancer, il va envoyer un signal à
son père, qui va le recevoir et définir le booléen &lt;code&gt;usr_interrupt&lt;/code&gt; à &lt;code&gt;TRUE&lt;/code&gt;,
ce qui provoquera l'arrêt de la boucle, et la fin du père (le fils aura déjà
terminé son exécution).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;NB: &lt;strong&gt;SIGUSR1&lt;/strong&gt; et &lt;strong&gt;SIGUSR2&lt;/strong&gt; sont des signaux propres à cette utilisation.&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Le parallélisme est un domaine très intéressant, car il apporte la problématique
de la communication inter-processus, et il faut être en mesure de quel type de
communication (tubes ou signaux) on a besoin.&lt;/p&gt;
&lt;p&gt;Dans le cas de &lt;code&gt;fork()&lt;/code&gt; (qui est un appel système lent à exécuter), on a pas
beaucoup de problème si on conçoit bien son code. Cependant on se retrouve avec
deux processus distincts !&lt;/p&gt;
&lt;p&gt;Vous vous en doutez, il y a une suite à tout cela, car le parallélisme ne s'arrête
pas là ! Vous découvrirez dans un prochain article un parallélisme moins complexe
à mettre en place : &lt;strong&gt;les threads&lt;/strong&gt;, qui, malgré leur simplicité, apportent leurs
lots de problèmes.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">David Delassus</dc:creator><pubDate>Thu, 31 Jan 2013 00:00:00 +0100</pubDate><guid>tag:www.lab-sl3.org,2013-01-31:articles/news/le-parallelisme-avec-fork.html</guid><category>os</category><category>fork</category><category>asm</category></item><item><title>Qu'est-ce qu'un processus ?</title><link>http://www.lab-sl3.org/articles/news/quest-ce-quun-processus.html</link><description>&lt;p&gt;On parle souvent en informatique de &lt;strong&gt;processus&lt;/strong&gt;, nous allons voir au travers
de cet article ce qui se cache derrière ce terme.&lt;/p&gt;
&lt;h2&gt;Un programme, une tâche&lt;/h2&gt;
&lt;p&gt;Lorsque l'utilisateur désire exécuter un programme, en général celui ci double-click
dessus, ou tape son nom (ou son chemin) dans la console.
Derrière ce procédé se cache tout un immense mécanisme :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;l'utilisateur va demander au système d'exploitation l'exécution du programme ;&lt;/li&gt;
&lt;li&gt;le système d'exploitation va charger le programme et parser sa structure, afin de repérer les &lt;em&gt;headers&lt;/em&gt; (contenant des informations définies par le compilateur
qui a assemblé le programme), les données et le code exécutable ;&lt;/li&gt;
&lt;li&gt;le système d'exploitation va placer les différentes structures à des endroits précis dans la RAM :&lt;ul&gt;
&lt;li&gt;le code sera placé dans le &lt;strong&gt;segment de code&lt;/strong&gt; (défini par la valeur du registre &lt;strong&gt;CS&lt;/strong&gt; ou &lt;strong&gt;ECS&lt;/strong&gt; sur du &lt;em&gt;32-bits&lt;/em&gt;) ;&lt;/li&gt;
&lt;li&gt;les données seront placées dans le &lt;strong&gt;segment de données&lt;/strong&gt; (défini par la valeur du registre &lt;strong&gt;DS&lt;/strong&gt; ou &lt;strong&gt;EDS&lt;/strong&gt;) ;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;le système d'exploitation va créer le tas (&lt;em&gt;heap&lt;/em&gt; en anglais) et la pile (définie par la valeur du registre &lt;strong&gt;SS&lt;/strong&gt; ou &lt;strong&gt;ESS&lt;/strong&gt;) ;&lt;/li&gt;
&lt;li&gt;le système d'exploitation va ensuite initialiser les différents pointeurs :&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SP&lt;/strong&gt; (ou &lt;strong&gt;ESP&lt;/strong&gt;) : pointera la fin du segment de pile (le sommet de la pile), il sera décrémenté pour chaque instruction &lt;code&gt;PUSH&lt;/code&gt; et incrémenté pour chaque instruction &lt;code&gt;POP&lt;/code&gt; ;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IP&lt;/strong&gt; (ou &lt;strong&gt;EIP&lt;/strong&gt;) : pointera vers le début du segment de code, il sera incrémenté après chaque instruction exécutée, et modifié pour chaque instruction &lt;code&gt;JMP&lt;/code&gt; ou &lt;code&gt;CALL&lt;/code&gt; ;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BP&lt;/strong&gt; (ou &lt;strong&gt;EBP&lt;/strong&gt;) : pointera vers le début du segment de pile (le début du tas), c'est le développeur qui se charge d'utiliser ce pointeur.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;l'exécution peut enfin se dérouler.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;L'ensemble de cette structure (représenté par le schéma ci-dessous) est appelé : une &lt;strong&gt;tâche&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img alt="schéma d'un processus" src="http://ompldr.org/vaGFkZg.png" /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;NB:&lt;/em&gt; &lt;em&gt;text&lt;/em&gt; est notre segment de code, &lt;em&gt;bss&lt;/em&gt; une extension du segment de données.&lt;/p&gt;
&lt;h2&gt;Une tâche, un processus&lt;/h2&gt;
&lt;p&gt;Associée à cette tâche, le système d'exploitation créé une nouvelle structure, comprenant :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;un identifiant : qui permet d'identifier la tâche parmi les autres ;&lt;/li&gt;
&lt;li&gt;une pile : chaque tâche possède sa propre pile (définie par &lt;strong&gt;SS&lt;/strong&gt;/&lt;strong&gt;ESS&lt;/strong&gt;) ;&lt;/li&gt;
&lt;li&gt;une page mémoire (ou plus si nécessaire) ;&lt;/li&gt;
&lt;li&gt;d'autres propriétés qu'il n'est pas nécessaire de décrire ici (priorité, limitation, ...).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cette structure forme le contexte de notre tâche, que l'on appelle : &lt;strong&gt;le processus&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Le système d'exploitation va donc pouvoir grâce à cette structure &lt;em&gt;switcher&lt;/em&gt; d'une tâche à l'autre selon un algorithme de répartition du temps CPU, c'est &lt;strong&gt;l'ordonnanceur&lt;/strong&gt;, la pierre angulaire du multitâche, son principe de fonctionnement est simple :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;on exécute pendant un temps défini la tâche (ce temps est défini par l'algorithme d'ordonnancement choisi, je vous laisse consulter &lt;a href="https://fr.wikipedia.org/wiki/Ordonnancement_dans_les_syst%C3%A8mes_d'exploitation#Types_d.27algorithmes"&gt;l'article Wikipédia&lt;/a&gt;) ;&lt;/li&gt;
&lt;li&gt;une fois le temps d'exécution écoulé, on coupe les interruptions (instruction &lt;code&gt;CLI&lt;/code&gt;) ;&lt;/li&gt;
&lt;li&gt;on sauvegarde l'état des registres dans la structure du processus ;&lt;/li&gt;
&lt;li&gt;on sélectionne la tâche à exécuter, et on récupère la valeur des registres depuis la structure du processus associé ;&lt;/li&gt;
&lt;li&gt;on défini les registres avec les valeurs récupérées précédemment ;&lt;/li&gt;
&lt;li&gt;on réactive les interruptions (instruction &lt;code&gt;STI&lt;/code&gt;) ;&lt;/li&gt;
&lt;li&gt;on exécute la nouvelle tâche pendant un temps défini (retour au premier point).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Un peu d'assembleur&lt;/h2&gt;
&lt;h3&gt;L'instruction JMP et CALL&lt;/h3&gt;
&lt;p&gt;Je vous ai parlé il y a peu des instructions &lt;code&gt;JMP&lt;/code&gt; et &lt;code&gt;CALL&lt;/code&gt;, en vous disant qu'elles avaient un effet sur le registre &lt;strong&gt;IP&lt;/strong&gt;/&lt;strong&gt;EIP&lt;/strong&gt;.
Mais je ne vous en ai pas dit plus.&lt;/p&gt;
&lt;p&gt;Voyons leurs effet :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;_start&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;      
    &lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
    &lt;span class="n"&gt;jmp&lt;/span&gt; &lt;span class="n"&gt;monlabel2&lt;/span&gt;   &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;Cette&lt;/span&gt; &lt;span class="n"&gt;instruction&lt;/span&gt; &lt;span class="n"&gt;aura&lt;/span&gt; &lt;span class="n"&gt;pour&lt;/span&gt; &lt;span class="n"&gt;effet&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;placer&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="n"&gt;adresse&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;monlabel2&lt;/span&gt; &lt;span class="n"&gt;dans&lt;/span&gt; &lt;span class="n"&gt;EIP&lt;/span&gt;
    &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;prochaine&lt;/span&gt; &lt;span class="n"&gt;instruction&lt;/span&gt; &lt;span class="err"&gt;à&lt;/span&gt; &lt;span class="err"&gt;ê&lt;/span&gt;&lt;span class="n"&gt;tre&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="err"&gt;é&lt;/span&gt;&lt;span class="n"&gt;cut&lt;/span&gt;&lt;span class="err"&gt;é&lt;/span&gt; &lt;span class="n"&gt;est&lt;/span&gt; &lt;span class="n"&gt;donc&lt;/span&gt; &lt;span class="n"&gt;au&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt; &lt;span class="n"&gt;monlabel2&lt;/span&gt;

&lt;span class="n"&gt;monlabel1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;xor&lt;/span&gt; &lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ax&lt;/span&gt;
    &lt;span class="n"&gt;ret&lt;/span&gt;

&lt;span class="n"&gt;monlabel2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;bx&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ax&lt;/span&gt;
    &lt;span class="n"&gt;jmp&lt;/span&gt; &lt;span class="n"&gt;monlabel1&lt;/span&gt;   &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;Cette&lt;/span&gt; &lt;span class="n"&gt;instruction&lt;/span&gt; &lt;span class="n"&gt;aura&lt;/span&gt; &lt;span class="n"&gt;pour&lt;/span&gt; &lt;span class="n"&gt;effet&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;placer&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="n"&gt;adresse&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;monlabel1&lt;/span&gt; &lt;span class="n"&gt;dans&lt;/span&gt; &lt;span class="n"&gt;EIP&lt;/span&gt;
    &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;prochaine&lt;/span&gt; &lt;span class="n"&gt;instruction&lt;/span&gt; &lt;span class="err"&gt;à&lt;/span&gt; &lt;span class="err"&gt;ê&lt;/span&gt;&lt;span class="n"&gt;tre&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="err"&gt;é&lt;/span&gt;&lt;span class="n"&gt;cut&lt;/span&gt;&lt;span class="err"&gt;é&lt;/span&gt; &lt;span class="n"&gt;est&lt;/span&gt; &lt;span class="n"&gt;donc&lt;/span&gt; &lt;span class="n"&gt;au&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt; &lt;span class="n"&gt;monlabel1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;L'instruction &lt;code&gt;JMP&lt;/code&gt; modifie donc directement le pointeur d'instruction, permettant ainsi
de faire un saut à un autre endroit de la mémoire.&lt;/p&gt;
&lt;p&gt;Contrairement à &lt;code&gt;JMP&lt;/code&gt;, l'instruction &lt;code&gt;CALL&lt;/code&gt; va empiler la valeur du registre &lt;strong&gt;EIP&lt;/strong&gt; avant le saut :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;monlabel&lt;/span&gt;

&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;é&lt;/span&gt;&lt;span class="n"&gt;quivaut&lt;/span&gt; &lt;span class="n"&gt;donc&lt;/span&gt; &lt;span class="err"&gt;à&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="n"&gt;eip&lt;/span&gt;
&lt;span class="n"&gt;jmp&lt;/span&gt; &lt;span class="n"&gt;monlabel&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pour revenir à l'instruction suivant l'instruction &lt;code&gt;CALL&lt;/code&gt;, un simple &lt;code&gt;RET&lt;/code&gt; suffit, son effet est de
dépiler sur la pile, pour récupérer la valeur du registre &lt;strong&gt;EIP&lt;/strong&gt; et y sauter :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;ret&lt;/span&gt;

&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;é&lt;/span&gt;&lt;span class="n"&gt;quivaut&lt;/span&gt; &lt;span class="n"&gt;donc&lt;/span&gt; &lt;span class="err"&gt;à&lt;/span&gt;
&lt;span class="n"&gt;pop&lt;/span&gt; &lt;span class="n"&gt;eax&lt;/span&gt;
&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;eip&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;eax&lt;/span&gt;
&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;pas&lt;/span&gt; &lt;span class="n"&gt;besoin&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;JMP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ici&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;eip&lt;/span&gt; &lt;span class="n"&gt;va&lt;/span&gt; &lt;span class="err"&gt;ê&lt;/span&gt;&lt;span class="n"&gt;tre&lt;/span&gt; &lt;span class="n"&gt;incr&lt;/span&gt;&lt;span class="err"&gt;é&lt;/span&gt;&lt;span class="n"&gt;ment&lt;/span&gt;&lt;span class="err"&gt;é&lt;/span&gt; &lt;span class="n"&gt;et&lt;/span&gt; &lt;span class="n"&gt;pointera&lt;/span&gt; &lt;span class="n"&gt;donc&lt;/span&gt; &lt;span class="n"&gt;sur&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;instruction&lt;/span&gt; &lt;span class="n"&gt;suivant&lt;/span&gt; &lt;span class="n"&gt;le&lt;/span&gt; &lt;span class="n"&gt;CALL&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Cette assimilation est simpliste et erronée car &lt;code&gt;CALL&lt;/code&gt; et &lt;code&gt;RET&lt;/code&gt; sont des &lt;strong&gt;opcodes&lt;/strong&gt; définis, mais
cela permet de bien comprendre leurs comportements.&lt;/p&gt;
&lt;p&gt;L'instruction &lt;code&gt;CALL&lt;/code&gt; permet donc de créer des fonctions en assembleur (couplé à l'instruction &lt;code&gt;RET&lt;/code&gt;)&lt;/p&gt;
&lt;h3&gt;Des fonctions, oui mais avec des arguments&lt;/h3&gt;
&lt;p&gt;On a deux écoles en &lt;em&gt;Assembleur&lt;/em&gt;, ceux qui passent leurs arguments via les registres :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;ebx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;mafonction&lt;/span&gt;

&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="err"&gt;é&lt;/span&gt;&lt;span class="n"&gt;sultat&lt;/span&gt; &lt;span class="n"&gt;dans&lt;/span&gt; &lt;span class="n"&gt;EAX&lt;/span&gt;
&lt;span class="nl"&gt;mafonction:&lt;/span&gt;
    &lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;edx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ebx&lt;/span&gt;
    &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;edx&lt;/span&gt;

    &lt;span class="n"&gt;ret&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Et ceux qui passent leurs arguments via la pile :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;mafonction&lt;/span&gt;

&lt;span class="nl"&gt;mafonction:&lt;/span&gt;
    &lt;span class="n"&gt;pop&lt;/span&gt; &lt;span class="n"&gt;edx&lt;/span&gt;
    &lt;span class="n"&gt;pop&lt;/span&gt; &lt;span class="n"&gt;eax&lt;/span&gt;
    &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;edx&lt;/span&gt;

    &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="n"&gt;eax&lt;/span&gt;

    &lt;span class="n"&gt;ret&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;STOOOOOOP !&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Vous ne voyez pas ? On &lt;code&gt;POP&lt;/code&gt; ! Mais, je vous rappelle que &lt;strong&gt;EIP&lt;/strong&gt; est sur la pile,
comment va faire &lt;code&gt;RET&lt;/code&gt; ?&lt;/p&gt;
&lt;p&gt;Ce n'est pas la bonne solution, voici la bonne solution :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;mafonction&lt;/span&gt;

&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;pass&lt;/span&gt;&lt;span class="err"&gt;é&lt;/span&gt; &lt;span class="n"&gt;deux&lt;/span&gt; &lt;span class="n"&gt;arguments&lt;/span&gt; &lt;span class="n"&gt;sur&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;pile&lt;/span&gt;
&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;il&lt;/span&gt; &lt;span class="n"&gt;faut&lt;/span&gt; &lt;span class="n"&gt;les&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="err"&gt;é&lt;/span&gt;&lt;span class="n"&gt;piler&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mais&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;en&lt;/span&gt; &lt;span class="n"&gt;fou&lt;/span&gt; &lt;span class="n"&gt;des&lt;/span&gt; &lt;span class="n"&gt;valeurs&lt;/span&gt;
&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;alors&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;modifie&lt;/span&gt; &lt;span class="n"&gt;directement&lt;/span&gt; &lt;span class="n"&gt;ESP&lt;/span&gt;
&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;comme&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;pile&lt;/span&gt; &lt;span class="n"&gt;stocke&lt;/span&gt; &lt;span class="n"&gt;des&lt;/span&gt; &lt;span class="n"&gt;entiers&lt;/span&gt; &lt;span class="n"&gt;sur&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="n"&gt;bits&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;soit&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="n"&gt;octets&lt;/span&gt;
&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;lui&lt;/span&gt; &lt;span class="n"&gt;ajoute&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="n"&gt;pour&lt;/span&gt; &lt;span class="n"&gt;remonter&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;deux&lt;/span&gt; &lt;span class="n"&gt;cases&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="err"&gt;é&lt;/span&gt;&lt;span class="n"&gt;moires&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;esp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;

&lt;span class="nl"&gt;mafonction:&lt;/span&gt;
    &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;On&lt;/span&gt; &lt;span class="n"&gt;sauvegarde&lt;/span&gt; &lt;span class="n"&gt;le&lt;/span&gt; &lt;span class="n"&gt;registre&lt;/span&gt; &lt;span class="n"&gt;EBP&lt;/span&gt; &lt;span class="n"&gt;sur&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;pile&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;va&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;en&lt;/span&gt; &lt;span class="n"&gt;servir&lt;/span&gt;
    &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;pour&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="err"&gt;é&lt;/span&gt;&lt;span class="n"&gt;der&lt;/span&gt; &lt;span class="err"&gt;à&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;pile&lt;/span&gt; &lt;span class="n"&gt;sans&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="n"&gt;et&lt;/span&gt; &lt;span class="n"&gt;pop&lt;/span&gt;
    &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="n"&gt;ebp&lt;/span&gt;
    &lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;ebp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;esp&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;stocke&lt;/span&gt; &lt;span class="n"&gt;le&lt;/span&gt; &lt;span class="n"&gt;sommet&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;pile&lt;/span&gt; &lt;span class="n"&gt;dans&lt;/span&gt; &lt;span class="n"&gt;notre&lt;/span&gt; &lt;span class="n"&gt;pointeur&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

    &lt;span class="n"&gt;pusha&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;sauvegarde&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;é&lt;/span&gt;&lt;span class="n"&gt;tat&lt;/span&gt; &lt;span class="n"&gt;des&lt;/span&gt; &lt;span class="n"&gt;registres&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;
    &lt;span class="n"&gt;pushf&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;sauvegarde&lt;/span&gt; &lt;span class="n"&gt;le&lt;/span&gt; &lt;span class="n"&gt;registre&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;

    &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;ici&lt;/span&gt; &lt;span class="n"&gt;ESP&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;chang&lt;/span&gt;&lt;span class="err"&gt;é&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mais&lt;/span&gt; &lt;span class="n"&gt;ce&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;est&lt;/span&gt; &lt;span class="n"&gt;pas&lt;/span&gt; &lt;span class="n"&gt;grave&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;ce&lt;/span&gt; &lt;span class="n"&gt;qui&lt;/span&gt; &lt;span class="n"&gt;nous&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="err"&gt;é&lt;/span&gt;&lt;span class="n"&gt;resse&lt;/span&gt; &lt;span class="n"&gt;dans&lt;/span&gt;
    &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;EBP&lt;/span&gt;

    &lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ebp&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;premier&lt;/span&gt; &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;
    &lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;edx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ebp&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;
    &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;edx&lt;/span&gt;

    &lt;span class="n"&gt;popf&lt;/span&gt;  &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;restaure&lt;/span&gt; &lt;span class="n"&gt;le&lt;/span&gt; &lt;span class="n"&gt;registre&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt;
    &lt;span class="n"&gt;popa&lt;/span&gt;  &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;restaure&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;é&lt;/span&gt;&lt;span class="n"&gt;tat&lt;/span&gt; &lt;span class="n"&gt;des&lt;/span&gt; &lt;span class="n"&gt;registres&lt;/span&gt;

    &lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;esp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ebp&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;restaure&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;é&lt;/span&gt;&lt;span class="n"&gt;tat&lt;/span&gt; &lt;span class="n"&gt;initial&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;ESP&lt;/span&gt;
    &lt;span class="n"&gt;pop&lt;/span&gt; &lt;span class="n"&gt;ebp&lt;/span&gt;      &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;puis&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;restaure&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;é&lt;/span&gt;&lt;span class="n"&gt;tat&lt;/span&gt; &lt;span class="n"&gt;initial&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;EBP&lt;/span&gt;

    &lt;span class="n"&gt;ret&lt;/span&gt;          &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;enfin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;peut&lt;/span&gt; &lt;span class="n"&gt;retourner&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;NB:&lt;/em&gt; On peut faire &lt;code&gt;ret 8&lt;/code&gt;, ce qui évite le &lt;code&gt;add esp, 8&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;NB:&lt;/em&gt; L'utilisation de &lt;code&gt;pusha pushf&lt;/code&gt; et de &lt;code&gt;popf popa&lt;/code&gt; empêche tout retour via les registres.
C'est utilisé dans le cas où la fonction ne renvoie rien, enlevez ces lignes si vous souhaitez
retourner quelque chose via les registres.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Voilà un petit tour de ce qu'est un processus, avec un petit peu d'assembleur pour
bien comprendre le concept de pile et d'adresse.&lt;/p&gt;
&lt;p&gt;Dans le prochain article, nous parlerons de parallélisme en C avec &lt;code&gt;fork()&lt;/code&gt;, il
est pour cela nécessaire de bien avoir compris le contenu de cet article.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">David Delassus</dc:creator><pubDate>Wed, 30 Jan 2013 18:00:00 +0100</pubDate><guid>tag:www.lab-sl3.org,2013-01-30:articles/news/quest-ce-quun-processus.html</guid><category>os</category><category>asm</category></item><item><title>Intégration de Python en C</title><link>http://www.lab-sl3.org/articles/news/integration-de-python-en-c.html</link><description>&lt;p&gt;L'intégration de Python en C peut être utile dans différents cas :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scripter l'application (configuration) ;&lt;/li&gt;
&lt;li&gt;système de plugins ;&lt;/li&gt;
&lt;li&gt;scinder l'application en deux parties (UI, coeur) ;&lt;/li&gt;
&lt;li&gt;faciliter le développement de certaines tâches.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cette intégration se fait en exposant certaines structures de données ou fonctions
en tant que module Python, et vice versa, c'est à dire rendre accessible au
programme C les structures de données ou fonctions du script au programme.&lt;/p&gt;
&lt;h2&gt;L'API C de Python&lt;/h2&gt;
&lt;p&gt;On commence par inclure le header Python :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;Python.h&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ceci nous offre la possibilité de créer diverse structures de données propres à
Python :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* création d&amp;#39;un tuple contenant 3 éléments */&lt;/span&gt;
&lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tuple&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PyTuple_New&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/* tuple[0] = 1 */&lt;/span&gt;
&lt;span class="n"&gt;PyTuple_SetItem&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tuple&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PyInt_FromLong&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1L&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="cm"&gt;/* tuple[1] = 2 */&lt;/span&gt;
&lt;span class="n"&gt;PyTuple_SetItem&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tuple&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PyInt_FromLong&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2L&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="cm"&gt;/* tuple[2] = &amp;quot;three&amp;quot; */&lt;/span&gt;
&lt;span class="n"&gt;PyTuple_SetItem&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tuple&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PyString_FromString&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;three&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Un autre exemple :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tuple&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;tuple&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Py_BuildValue&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;(iis)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;three&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;list&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Py_BuildValue&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;[iis]&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;three&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pour plus d'informations sur l'API, je vous renvoi vers la &lt;a href="http://docs.python.org/2/c-api/"&gt;documentation&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Exécuter Python dans un programme C&lt;/h2&gt;
&lt;p&gt;Voici un exemple très simple :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;Python.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Py_SetProgramName&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt; &lt;span class="cm"&gt;/* pas obligatoire mais recommandé, cela va définir __name__ */&lt;/span&gt;

    &lt;span class="n"&gt;Py_Initialize&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;PyRun_SimpleString&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;from time import time, ctime&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;print &amp;#39;Today is&amp;#39;, ctime(time())&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;Py_Finalize&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Maintenant, on sait comment exécuter un script au sein de notre application.&lt;/p&gt;
&lt;h2&gt;Importer, exécuter&lt;/h2&gt;
&lt;p&gt;Imaginons que nous ayons un module Python que l'on désire utiliser.
Par exemple :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;# multiply.py&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;multiply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Will compute&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;times&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

    &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Nous allons donc importer le module &lt;code&gt;multiply&lt;/code&gt;, appeler la fonction
&lt;code&gt;multiply()&lt;/code&gt; et terminer le programme.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;Python.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;module_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;      &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* stdio.h, stdlib.h, string.h, ... sont inclus par Python.h */&lt;/span&gt;
        &lt;span class="n"&gt;fprintf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Usage: call &amp;lt;python module&amp;gt; &amp;lt;function&amp;gt; [args]&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* on initialise l&amp;#39;environnement Python */&lt;/span&gt;
    &lt;span class="n"&gt;Py_Initialize&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="cm"&gt;/* On récupère le nom du module dans un objet string compris par Python */&lt;/span&gt;
    &lt;span class="n"&gt;module_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PyString_FromString&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

    &lt;span class="cm"&gt;/* on importe le module&lt;/span&gt;
&lt;span class="cm"&gt;     *&lt;/span&gt;
&lt;span class="cm"&gt;     * import &amp;lt;module_name&amp;gt;&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PyImport_Import&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;module_name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* On a plus besoin de l&amp;#39;objet module_name !&lt;/span&gt;
&lt;span class="cm"&gt;     * nous allons donc supprimer la référence que nous avons dessus,&lt;/span&gt;
&lt;span class="cm"&gt;     * afin que le Garbage Collector de Python puisse le supprimer&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="n"&gt;Py_DECREF&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;module_name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* On récupère la fonction présente dans le module,&lt;/span&gt;
&lt;span class="cm"&gt;         * il s&amp;#39;agit ici de faire :&lt;/span&gt;
&lt;span class="cm"&gt;         *&lt;/span&gt;
&lt;span class="cm"&gt;         * function = getattr (&amp;lt;module&amp;gt;, &amp;lt;function name&amp;gt;)&lt;/span&gt;
&lt;span class="cm"&gt;         */&lt;/span&gt;
        &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PyObject_GetAttrString&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

        &lt;span class="cm"&gt;/* on vérifie que notre fonction existe, et qu&amp;#39;il s&amp;#39;agit bien&lt;/span&gt;
&lt;span class="cm"&gt;         * d&amp;#39;un objet que l&amp;#39;on peut appeler.&lt;/span&gt;
&lt;span class="cm"&gt;         */&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;PyCallable_Check&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="cm"&gt;/* on va créer un tuple qui contiendra les arguments&lt;/span&gt;
&lt;span class="cm"&gt;             * à passer à notre fonction.&lt;/span&gt;
&lt;span class="cm"&gt;             */&lt;/span&gt;
            &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PyTuple_New&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

            &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="cm"&gt;/* on convertit l&amp;#39;argument de la ligne de commande en&lt;/span&gt;
&lt;span class="cm"&gt;                 * objet int, compris par Python&lt;/span&gt;
&lt;span class="cm"&gt;                 */&lt;/span&gt;
                &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PyInt_FromLong&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strtol&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="cm"&gt;/* il y a eu une erreur, on déréférence tout */&lt;/span&gt;
                    &lt;span class="n"&gt;Py_DECREF&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                    &lt;span class="n"&gt;Py_DECREF&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

                    &lt;span class="n"&gt;fprintf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Can&amp;#39;t convert argument to long : %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
                    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;

                &lt;span class="cm"&gt;/* la référence vers value ici est &amp;quot;volée&amp;quot;, pas besoin de la&lt;/span&gt;
&lt;span class="cm"&gt;                 * déréférencer.&lt;/span&gt;
&lt;span class="cm"&gt;                 */&lt;/span&gt;
                &lt;span class="n"&gt;PyTuple_SetItem&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;

            &lt;span class="cm"&gt;/* on appelle la fonction et on récupère son retour :&lt;/span&gt;
&lt;span class="cm"&gt;             * value = function (*args)&lt;/span&gt;
&lt;span class="cm"&gt;             */&lt;/span&gt;
            &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PyObject_CallObject&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

            &lt;span class="cm"&gt;/* on a plus besoin de args, on laisse le Garbage Collector faire */&lt;/span&gt;
            &lt;span class="n"&gt;Py_DECREF&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="cm"&gt;/* on affiche le résultat */&lt;/span&gt;
                &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Result of call: %ld&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PyInt_AsLong&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

                &lt;span class="cm"&gt;/* on a plus besoin de value */&lt;/span&gt;
                &lt;span class="n"&gt;Py_DECREF&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="cm"&gt;/* une erreur a eu lieu, on déréférence tout et on l&amp;#39;affiche */&lt;/span&gt;
                &lt;span class="n"&gt;Py_DECREF&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;Py_DECREF&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

                &lt;span class="n"&gt;PyErr_Print&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;

                &lt;span class="n"&gt;fprintf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Call failed!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="cm"&gt;/* la fonction n&amp;#39;existe pas, ou ce n&amp;#39;est pas une fonction */&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyErr_Occured&lt;/span&gt; &lt;span class="p"&gt;())&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;PyErr_Print&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;

            &lt;span class="n"&gt;fprintf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Cannot find function: %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="cm"&gt;/* on a plus besoin de la fonction et du module */&lt;/span&gt;
        &lt;span class="n"&gt;Py_XDECREF&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="cm"&gt;/* XDECREF : si function est NULL, ne fais rien */&lt;/span&gt;
        &lt;span class="n"&gt;Py_DECREF&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* on a pas pu charger le module */&lt;/span&gt;
        &lt;span class="n"&gt;PyErr_Print&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;

        &lt;span class="n"&gt;fprintf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Failed to load module: %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* on termine l&amp;#39;environnement Python */&lt;/span&gt;
    &lt;span class="n"&gt;Py_Finalize&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;EXIT_SUCCESS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;On sait désormais comment appeler des fonctions Python et comment manipuler des
objets Python en C.&lt;/p&gt;
&lt;h2&gt;Exposer un module à Python&lt;/h2&gt;
&lt;p&gt;C'est bien beau tout ça, mais un intérêt non-négligeable est de pouvoir fournir
à Python des fonctions et structures de données de notre programme !&lt;/p&gt;
&lt;p&gt;Pour cela, on créé un module dans lequel on expose notre API :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;Python.h&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;numargs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/* une fonction que l&amp;#39;on expose retourne toujours un PyObject* et prend&lt;/span&gt;
&lt;span class="cm"&gt; * toujours un argument self, qui est l&amp;#39;objet appelant la fonction (l&amp;#39;objet&lt;/span&gt;
&lt;span class="cm"&gt; * dans le cas d&amp;#39;une méthode, le module dans le cas d&amp;#39;une fonction orpheline)&lt;/span&gt;
&lt;span class="cm"&gt; * et un argument args, qui est un tuple contenant les arguments de notre&lt;/span&gt;
&lt;span class="cm"&gt; * fonction.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;mymodule_numargs&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* tout ce qui précède le &amp;#39;:&amp;#39; correspond au type de chacun des&lt;/span&gt;
&lt;span class="cm"&gt;     * argument attendu par notre fonction, ce qui suit est le nom&lt;/span&gt;
&lt;span class="cm"&gt;     * associé à notre fonction pour le retour d&amp;#39;erreur.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;PyArg_ParseTuple&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;:numargs&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Py_BuildValue&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;i&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;numargs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* Tableau NULL-terminated de tout les éléments présents dans notre&lt;/span&gt;
&lt;span class="cm"&gt; * module&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;PyMethodDef&lt;/span&gt; &lt;span class="n"&gt;mymodule_methods&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;numargs&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mymodule_numargs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;METH_VARARGS&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Return the number of arguments received by the process.&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;numargs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* on initialise l&amp;#39;environnement python */&lt;/span&gt;
    &lt;span class="n"&gt;Py_Initialize&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="cm"&gt;/* on créé notre module */&lt;/span&gt;
    &lt;span class="n"&gt;Py_InitModule&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;mymodule&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mymodule_methods&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;PyRun_SimpleString&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;import mymodule&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;print &amp;#39;Number of arguments:&amp;#39;, mymodule.numargs()&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;Py_Finalize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;EXIT_SUCCESS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Pour le moment, on sait exporter des fonctions/données vers Python, on sait aussi
interagir avec Python. Il reste encore à voir comment créer des objets en C pour
les exporter vers Python, ce sera l'objet d'un prochain article, car c'est une
chose assez conséquente !&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">David Delassus</dc:creator><pubDate>Tue, 29 Jan 2013 17:35:00 +0100</pubDate><guid>tag:www.lab-sl3.org,2013-01-29:articles/news/integration-de-python-en-c.html</guid><category>c</category><category>python</category></item><item><title>La compression de données avec RLE</title><link>http://www.lab-sl3.org/articles/news/la-compression-de-donnees-avec-rle.html</link><description>&lt;p&gt;La compression de données est un domaine assez important dans le monde de
l'informatique. C'est notre unique moyen pour transférer des données à la taille
conséquente de manière plus rapide. Et il existe de nombreux algorithmes que l'on
classe dans deux catégories : compression avec pertes, compression sans pertes.&lt;/p&gt;
&lt;p&gt;Dans la première catégorie, on a par exemple l'algorithme &lt;strong&gt;JPEG&lt;/strong&gt;. Dans la
seconde catégorie, on aura l'algorithme &lt;strong&gt;RLE&lt;/strong&gt;, dont nous étudierons le
fonctionnement dans la suite de cet article.&lt;/p&gt;
&lt;h2&gt;La compression avec pertes&lt;/h2&gt;
&lt;p&gt;Le principe de ce type de compression est de réduire la taille des données en
supprimant les données jugées superflues.&lt;/p&gt;
&lt;p&gt;Prenons l'exemple de l'aglorithme &lt;strong&gt;JPEG&lt;/strong&gt;. Ce dernier va repérer les pixels de
l'image qui n'apporte à celle ci que de la qualité (du détail) et les supprimer.&lt;/p&gt;
&lt;p&gt;Le problème de ce genre de compression est qu'il est impossible de récupérer ses
données lors de la décompression.&lt;/p&gt;
&lt;h2&gt;La compression sans pertes&lt;/h2&gt;
&lt;p&gt;Contrairement à la compression avec pertes, la compression sans pertes va
préserver les données. Pour cela, on encode les données pour en réduire la taille.&lt;/p&gt;
&lt;p&gt;Autant dire que c'est ce qui nous intéresse, on a comme algorithmes :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RLE, que nous étudierons ici ;&lt;/li&gt;
&lt;li&gt;tar ;&lt;/li&gt;
&lt;li&gt;RAR ;&lt;/li&gt;
&lt;li&gt;LZMA ;&lt;/li&gt;
&lt;li&gt;GZip, BZip, ZIP ;&lt;/li&gt;
&lt;li&gt;CPIO ;&lt;/li&gt;
&lt;li&gt;etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Un exemple avec RLE&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;RLE&lt;/strong&gt; signifie &lt;em&gt;&lt;strong&gt;R&lt;/strong&gt;un-&lt;strong&gt;L&lt;/strong&gt;ength &lt;strong&gt;E&lt;/strong&gt;ncoding&lt;/em&gt;. Le principe est simple, pour
chaque bloc de données identique, on l'écrit précédé du nombre de fois qu'il
apparaît consécutivement. Pour la décompression, il suffit de lire le nombre
d'occurences, et d'écrire l'entité autant de fois que nous le dicte le nombre.&lt;/p&gt;
&lt;p&gt;Prenons cete chaîne de caractères :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;WWWWWWBBBBBTTTTTGGGGDDDDEEEEWWWW&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Une fois l'algorithme &lt;em&gt;RLE&lt;/em&gt; effectué, les données compressées ressembleront à
ceci :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="n"&gt;W5B5T4G4D4E4W&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vous voyez tout de suite que les données sont plus courtes ! Faisons un peu de
calcul. Notre chaîne initiale a une longueur de &lt;strong&gt;32&lt;/strong&gt; caractères, la chaîne
compressée a une longueur de &lt;strong&gt;14&lt;/strong&gt; caractères, on cherche &lt;code&gt;X&lt;/code&gt; le taux de
compression :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;
&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;43.75&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Nous avons un taux de compression de &lt;strong&gt;43,75%&lt;/strong&gt;. C'est pas mal ! Cependant,
faisons la même chose pour cette chaîne :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;WBWBWBWBWBWBWBWB&lt;/span&gt;
&lt;span class="o"&gt;--&amp;gt;&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;W1B1W1B1W1B1W1B1W1B1W1B1W1B1W1B&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;La taille a doublé ! Calculons à nouveau le taux de compression :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;
&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Notre taux de compression est de &lt;strong&gt;200%&lt;/strong&gt; !&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note: Il est facile de s'apercevoir que plus le taux de compression est faible,
plus l'algorithme est performant.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Bien que l'algorithme &lt;em&gt;RLE&lt;/em&gt; soit très peu performant, il est notamment utilisé
pour le format d'image &lt;strong&gt;BMP&lt;/strong&gt;. Il est quand même intéressant de l'aborder pour
une introduction.&lt;/p&gt;
&lt;h2&gt;Implémentation en langage Python&lt;/h2&gt;
&lt;p&gt;Implémentons cet algorithme avec le langage Python :&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;

&lt;span class="c"&gt;# Ce module nous permettra de regrouper notre chaîne de caractères&lt;/span&gt;
&lt;span class="c"&gt;# en une liste de tuples ayant pour structure :&lt;/span&gt;
&lt;span class="c"&gt;# ( n occurences, élément )&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;itertools&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;encoded&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;

    &lt;span class="c"&gt;# itertools.groupby() va grouper notre chaîne en une&lt;/span&gt;
    &lt;span class="c"&gt;# liste de tuples contenant chacun l&amp;#39;occurence et la&lt;/span&gt;
    &lt;span class="c"&gt;# liste de chacune d&amp;#39;entre elles&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;itertools&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;groupby&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c"&gt;# on va donc créer un nouveau tuple dont le premier&lt;/span&gt;
        &lt;span class="c"&gt;# élément est la longueur de la liste, soit le nombre&lt;/span&gt;
        &lt;span class="c"&gt;# d&amp;#39;occurences, et le deuxième membre, l&amp;#39;occurence en&lt;/span&gt;
        &lt;span class="c"&gt;# elle même&lt;/span&gt;
        &lt;span class="n"&gt;block&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
            &lt;span class="n"&gt;name&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="c"&gt;# on ajoute ensuite ce tuple à la liste&lt;/span&gt;
        &lt;span class="n"&gt;encoded&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;block&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;encoded&lt;/span&gt;

    &lt;span class="c"&gt;# ou alors, en une seule ligne :&lt;/span&gt;
    &lt;span class="c"&gt;# return [(len(list(group)), name) for name , group in itertools.groupby(string)]&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rle&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;decoded&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;

    &lt;span class="c"&gt;# pour chaques tuples ( N , DATA ) de nos données compressées&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;block&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;rle&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="c"&gt;# on ajoute N fois DATA à notre liste&lt;/span&gt;
        &lt;span class="n"&gt;decoded&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;block&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;block&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;decoded&lt;/span&gt;

    &lt;span class="c"&gt;# ou alors, en une seule ligne :&lt;/span&gt;
    &lt;span class="c"&gt;# return sum([b[0] * [b[1]] for b in rle], [])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;L'algorithme &lt;strong&gt;RLE&lt;/strong&gt; est simpliste, et permet de voir toutes les problématiques
liées à la compression de données :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;le taux de compression dépend du type de données à compresser ;&lt;/li&gt;
&lt;li&gt;l'implémentation de l'algorithme n'est pas le plus complexe (comme toujours) ;&lt;/li&gt;
&lt;li&gt;le choix du type d'algorithme à utiliser selon le type de données n'est pas
  toujours évident.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dans un prochain article, je vous parlerai de &lt;strong&gt;Huffman&lt;/strong&gt;.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">David Delassus</dc:creator><pubDate>Mon, 28 Jan 2013 18:00:00 +0100</pubDate><guid>tag:www.lab-sl3.org,2013-01-28:articles/news/la-compression-de-donnees-avec-rle.html</guid><category>compression</category><category>python</category></item><item><title>Présentation du projet ArduiWasher</title><link>http://www.lab-sl3.org/articles/news/presentation-du-projet-arduiwasher.html</link><description>&lt;p&gt;Pour bien débuter, en tant que membre du SL3, je vais vous présenter un projet sur lequel je travaille actuellement, ArduiWasher. Il s'agit de mon premier projet concret utilisant le microcontrôleur d'Arduino en tant que contrôleur et programme d'un lave-linge.
Pour ceux qui se demandent ce qu'est l'&lt;a href="http://owni.fr/2011/12/16/arduino-naissance-mythe-bidouille/"&gt;Arduino&lt;/a&gt;, l'idée est de permettre à n'importe qui de réaliser des montages électroniques plus ou moins élaborés, d'une façon assez simple, en ayant recours à la programmation (langage C/C++).&lt;/p&gt;
&lt;p&gt;Le programme d'origine du lave-linge (programme mécanique, du type carte à trous) ne fonctionnait plus correctement, il m'est alors venu l'idée de tenter d'en réaliser un électronique, ce qui éviterait de tout remplacer.
Je me suis donc penché sur les divers actionneurs et détecteurs intégrés, comprendre le fonctionnement de chacun d'entre eux (sauf le système de chauffage, actuellement non utilisé, je le verrais un peu plus tard).&lt;/p&gt;
&lt;p&gt;Actionneurs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Moteur (rotations du tambour)&lt;/li&gt;
&lt;li&gt;Solénoïde (arrivée d'eau)&lt;/li&gt;
&lt;li&gt;Pompe (vidange)&lt;/li&gt;
&lt;li&gt;Interlock (verrouillage)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Détecteurs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pression (indique la fin du remplissage)&lt;/li&gt;
&lt;li&gt;Interlock (indique que la porte est fermée et vérouillée)&lt;/li&gt;
&lt;li&gt;Divers boutons de choix du programme et de lancement&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Il m'a fallu considérer séparément chaque élément un par un pour comprendre son fonctionnement, le moteur m'a pris assez longtemps, quelques recherches sur Internet, diverses mesures, et divers essais. Le solénoïde et la pompe aucun souci. J'ai démonté l'interlock pour comprendre comment il fonctionnait, de ce fait j'ai pu le cibler facilement aussi. Pour le capteur de pression j'ai simulé un remplissage en y branchant ma pompe de dessouder pour faire office de source de pression, et j'ai testé les entrées-sorties voir comment réagissait le composant.
Pour chaque élément j'ai réalisé un schéma de ciblage simplifié pour l'interfacer avec l'Arduino.&lt;/p&gt;
&lt;p&gt;Voilà par exemple le schéma de contrôle moteur.&lt;/p&gt;
&lt;p&gt;&lt;img alt="selenoide" src="https://dl.dropbox.com/u/1479070/DIY/Electronics/Washing%20Machine/selni_control.png" /&gt;&lt;/p&gt;
&lt;p&gt;Et ici, le schéma du système de remplissage/vidange d'eau.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://dl.dropbox.com/u/1479070/DIY/Electronics/Washing%20Machine/filling_leak_control.png" /&gt;&lt;/p&gt;
&lt;p&gt;J'ai également réalisé les schémas des divers modules nécessaires à la carte contrôleur.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://dl.dropbox.com/u/1479070/DIY/Electronics/Washing%20Machine/relay_control.png" /&gt;&lt;/p&gt;
&lt;p&gt;Détecteur de courant alternatif (220VAC). Celui-ci m'a pris du temps, beaucoup de recherche sur internet, et d'essai en conditions réelles.&lt;/p&gt;
&lt;p&gt;&lt;img alt="detector" src="https://dl.dropbox.com/u/1479070/DIY/Electronics/Washing%20Machine/ac_detector.png" /&gt;&lt;/p&gt;
&lt;p&gt;Les composants électroniques nécessaires à la réalisation de ces circuits venaient en partie de mon kit de débutant de l'Arduino, et surtout en grande partie d'un ancien onduleur qui trainait dans la remise. Je l'ai désassemblé pour récupérer des diodes, les relais, et des condensateurs de sécurité utiles aux circuits de détection AC.&lt;/p&gt;
&lt;p&gt;Une fois tout les schémas et circuits terminés et en état de fonctionnement, je me suis mis au code source du programme sur l'Arduino ! Donc pour présenter les choses déjà, je n'utilise pas l'IDE Arduino. Etant habitué à développer en général, je trouve l'environnement par défaut trop minimal, aucune auto-complétion, impossibilité de programmer en orienté objet et j'en passe... Je me suis mis à la recherche d'une solution pour développer réellement en C/C++ et avec un environnement plus approprié. J'ai pu découvrir que l'IDE Arduino n'est en réalité qu'une interface pour tous les outils en ligne de commande (gcc, g++,...). Il existait divers &lt;a href="http://playground.arduino.cc/code/eclipse"&gt;tutoriels&lt;/a&gt; permettant de configurer un environnement Eclipse pour développer correctement. J'ai donc pu configurer ainsi mon IDE favori (j'utilisais Eclipse depuis un bon moment déjà pour développer en Java sous Android) pour faire du développement pour la plateforme Arduino.&lt;/p&gt;
&lt;p&gt;Certaines fonctionnalités du langage C++ ne sont pas utilisables en développant sur cette plateforme, comme les collections, de plus, il n'est pas conseillé d'utiliser abusivement les opérateurs new et delete, par exemple. Je m'étais fait piéger un jour par un int que j'utilisais comme timer, qui dépassait la valeur maximale possible, et qui résultait en un bug que j'ai eu du mal à trouver pendant un moment). &lt;a href="http://arduino.cc/en/Reference/Int"&gt;Ne pas oublier donc, sur un Arduino Uno, un int correspond à un entier de 16-bits&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Pour revenir au programme, j'ai opté pour la séparation de la gestion de chaque élément par classes :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;actuators/Interlock.h (verrouillage)&lt;/li&gt;
&lt;li&gt;actuators/Motor.h (moteur)&lt;/li&gt;
&lt;li&gt;actuators/Water.h (arrivée d'eau, et vidange)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Le dossier 'programs' contient l'ensemble des classes correspondant à chaque programme de lavage. Actuellement un seul programme est disponible à des fins de test, le programme 'Default'. La gestion sera améliorée une fois que tout les bugs seront corrigés, et il sera possible via un affichage, de choisir le programme que l'on souhaite lancer, et d'avoir un timer indiquant le temps restant avant la fin du lavage. Les possibilités sont quasi-infinies, ensuite, avec une peu d'imagination. Il est possible par exemple de relier le tout au réseau, afin de régler à distance un timer, sélectionner le programme depuis son smartphone, et pourquoi pas, si une erreur survient, l'envoyer à un serveur syslog ?&lt;/p&gt;
&lt;p&gt;Le projet se trouve sur GitHub à l'adresse suivante: &lt;a href="https://github.com/etienne51/ArduiWasher"&gt;https://github.com/etienne51/ArduiWasher&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://dl.dropbox.com/u/1479070/DIY/Electronics/Washing%20Machine/img3.jpg"&gt;&lt;img src="https://dl.dropbox.com/u/1479070/DIY/Electronics/Washing%20Machine/img3.jpg" alt="arduiwasher" width="400" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Etienne Dubois.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Étienne Dubois</dc:creator><pubDate>Thu, 24 Jan 2013 12:00:00 +0100</pubDate><guid>tag:www.lab-sl3.org,2013-01-24:articles/news/presentation-du-projet-arduiwasher.html</guid><category>arduino</category><category>etienne51</category><category>c</category><category>cpp</category><category>electronique</category></item><item><title>Ouverture du laboratoire à Nantes</title><link>http://www.lab-sl3.org/articles/news/ouverture-du-laboratoire-a-nantes.html</link><description>&lt;p&gt;Bonjour,&lt;/p&gt;
&lt;p&gt;Le Labo SL3 débarque à Nantes. Ce laboratoire s'intéresse principalement au développement "bas niveau" tel que le fonctionnement des systèmes d'exploitation, l'architecture des ordinateurs, la compilation, la création de langage ou de machine virtuelle telle que la JVM. Ce laboratoire est également là pour aborder d'autres thèmes tel que l'algorithmique, les différents paradigmes de programmation (impératif, objet, fonctionnel, logique etc.) la programmation
concurrente/parallèle avec des langages tels que le C, C++ ou encore le langage Go. &lt;/p&gt;
&lt;p&gt;La programmation est un élément central du laboratoire. Ainsi, un projet au niveau global est prévu. Son but est d'implémenter une machine virtuelle (exemple: la JVM). Ce projet se veut être un vrai projet de recherche. Il est également possible de proposer d'autres projets au niveau local ou global, d'autres projets sont déjà proposés tel qu' un projet d'OS ou encore une alternative à emu8086.&lt;/p&gt;
&lt;p&gt;Le rôle de laboratoire au niveau local est de gérer les projets locaux ainsi que organiser des lightnings talks sur différents sujets (machine learning, C++11, etc.). Comme vous le voyez, les activités proposées par ce laboratoire sont diverses et il est ouvert a toute personne s'intéressant et désirant se perfectionner dans ces domaines quel soit son niveau. &lt;/p&gt;
&lt;p&gt;Si vous êtes intéressés par les activités de notre laboratoire, n'hésitez pas à me contacter à &lt;a href="mailto:simon.rouger@supinfo.com"&gt;simon.rouger@supinfo.com&lt;/a&gt; !&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">SL3 Team</dc:creator><pubDate>Thu, 17 Jan 2013 13:56:14 +0100</pubDate><guid>tag:www.lab-sl3.org,2013-01-17:articles/news/ouverture-du-laboratoire-a-nantes.html</guid><category>sl3</category><category>nantes</category></item><item><title>Ouverture du SUPINFO Low-Level Laboratory (SL3)</title><link>http://www.lab-sl3.org/articles/news/ouverture-du-supinfo-low-level-laboratory-sl3.html</link><description>&lt;p&gt;Bonjour,&lt;/p&gt;
&lt;p&gt;c'est avec joie que l'équipe du SL3 est fière de vous annoncer la création de ce laboratoire. L'objectif de ce projet est de ressembler les étudiants autour de tout ce qui se rapproche du &amp;laquo; bas-niveau &amp;raquo; c'est-à-dire des couches informatiques les plus basses. Au delà d'un simple domaine, la philosophie est d'explorer en profondeur les outils qu'un développeur utilise chaque jour.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/tKJ0W.png" style="float: left; padding: 5px;" /&gt;&lt;/p&gt;
&lt;p&gt;Concrètement, le SL3 abordera des sujets comme tout ce qui gravite autour de l'étude des systèmes d'exploitations, langages informatiques et du développement. Comment fonctionne un driver sous Linux ? Comment créer un système d'exploitation ? Que se passe-t'il quand on compile un fichier source ? Voici le genre de problématique auxquelles nous nous intéressons.&lt;/p&gt;
&lt;p&gt;Pour en savoir plus les intentions du SL3, je vous invite à lire la page de présentation : &lt;a href="/pages/presentation-du-sl3.html"&gt;Présentation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Si vous avez des questions ou que vous souhaitez vous inscrire, n'hésitez pas à envoyer un mail à &lt;a href="mailto:timothee.bernard@supinfo.com"&gt;timothee.bernard@supinfo.com&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;N'hésitez pas non plus à venir nous rejoindre sur &lt;a href="/forums/"&gt;nos forums&lt;/a&gt; ou sur notre channel IRC : #sl3@irc.supnetwork.org !&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">SL3 Team</dc:creator><pubDate>Thu, 10 Jan 2013 18:00:00 +0100</pubDate><guid>tag:www.lab-sl3.org,2013-01-10:articles/news/ouverture-du-supinfo-low-level-laboratory-sl3.html</guid><category>sl3</category><category>montreal</category></item></channel></rss>